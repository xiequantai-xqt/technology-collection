设计模式是经过验证的解决方案，为特定类型的问题提供了一种结构或框架，使得开发人员可以更快、更高效地解决问题，而不必从头开始设计。

设计模式通常描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心结构，从而使你可以在多种不同的情况下应用这个解决方案。

设计模式一般分为创建型模式、结构型模式、行为型模式。

![](https://guiwanzhyq.oss-cn-hangzhou.aliyuncs.com/hc/img/20240717/e2c43580-7b58-4722-bf63-21f7e010b8e5.png)

# 创建型模式

> 特点：关注对象的创建机制，确保系统能够以一种灵活的方式创建所需的对象实例。

## 单例模式

在JavaScript中，单例模式是一种设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。这个模式的主要目的是限制对象的创建，节省资源，特别是在对象创建成本较高或需要共享状态的场景下。

在JavaScript里实现单例模式通常有两种常见的方法：使用闭包和构造函数加静态方法。

### 使用闭包实现单例

> 闭包允许你创建私有变量和方法，同时也能保证只创建一次实例。下面是一个使用闭包实现的单例模式示例：

```javascript
const Singleton = (function() {
    let instance;

    function createInstance() {
        const object = new Object("I am the single instance");
        return object;
    }

    return {
        getInstance: function() {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();

const firstInstance = Singleton.getInstance();
const secondInstance = Singleton.getInstance();

console.log(firstInstance === secondInstance); // true
```

在这个例子中，`createInstance` 函数只在首次调用 `getInstance` 方法时被调用，之后的调用都会返回第一次创建的实例。

### 使用构造函数和静态方法实现单例

另一种方法是在构造函数中检查是否已经存在一个实例，如果存在则直接返回该实例，否则创建新实例并保存起来。这种方式通常会利用静态方法来提供对单例的访问。

```javascript
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = this;
        }
        return Singleton.instance;
    }

    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }

    someMethod() {
        console.log("This is the only instance of Singleton.");
    }
}

const firstInstance = Singleton.getInstance();
const secondInstance = Singleton.getInstance();

console.log(firstInstance === secondInstance); // true
```

在这个例子中，`getInstance` 是一个静态方法，可以直接通过类来调用，而不需要创建一个新的实例。当尝试创建一个新的 `Singleton` 实例时，构造函数会检查是否存在一个实例，如果存在则返回已有的实例。

这两种方法都能有效地实现单例模式，具体选择哪一种取决于你的需求和代码风格。

## 工厂模式

在JavaScript中，工厂模式是一种设计模式，用于封装对象的创建过程。这种模式的主要目的是为了隐藏对象创建的细节，同时提供一个公共的接口来创建一系列相关的或具有相同功能的对象。

### 原理

工厂模式的核心思想是将对象的创建过程从使用对象的地方解耦出来。

这样做的好处包括：

1. **代码的解耦**：对象的创建逻辑被封装在工厂内，使得客户端代码不必知道具体的创建逻辑，也不必了解对象的确切类型。
2. **易于扩展**：当需要增加新的对象类型时，只需要修改工厂的实现，而不必修改客户端代码。
3. **更好的代码组织**：工厂模式可以帮助管理代码结构，特别是当项目变得庞大且有多个不同类型的对象需要创建时。

### 分类

> 工厂模式可以进一步细分为以下几种类型

- **简单工厂**（也称静态工厂）：由一个类负责创建所有实例。通常，这个类有一个静态方法，接受参数并决定创建哪个类的实例。简单工厂的缺点是它违反了开闭原则，因为每当需要一个新的对象类型时，都需要修改工厂类。
- **工厂方法**（Factory Method）：定义一个创建对象的接口，但允许子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。
- **抽象工厂**（Abstract Factory）：提供一个接口来创建一系列相关或相互依赖的对象，而无需指定它们具体的类。抽象工厂模式通常用于创建一组对象，这些对象属于同一主题或系列。

### 示例

#### 简单工厂

```javascript
// 简单工厂模式示例

function createShape(type) {
    if (type === 'circle') {
        return new Circle();
    } else if (type === 'square') {
        return new Square();
    }
}

class Circle {
    draw() {
        console.log('Drawing a circle.');
    }
}

class Square {
    draw() {
        console.log('Drawing a square.');
    }
}

// 使用工厂创建形状
const shape1 = createShape('circle');
shape1.draw(); // 输出 "Drawing a circle."

const shape2 = createShape('square');
shape2.draw(); // 输出 "Drawing a square."
```

在这个例子中，`createShape` 函数充当了一个工厂，根据传入的类型参数创建不同的形状对象。客户端代码只需调用 `createShape` 函数并传入适当的参数即可，而不需要知道具体的形状类是如何实现的。



#### 工厂方法模式

首先，我们定义一个抽象基类 `Shape`，它包含一个抽象方法 `draw` 和一个工厂方法 `createShape`。然后，我们创建两个具体的图形类 `Circle` 和 `Square`，它们继承自 `Shape` 并实现了各自的 `draw` 方法和工厂方法 `createShape`。

> 注意：
>
> 1. 当你在一个子类中定义了一个与父类同名的静态方法时，实际上是在子类中覆盖（重写）了父类的静态方法。这是完全可行的，并且与类的实例方法覆盖规则类似，但只限于静态上下文。
> 2. 子类覆盖父类的静态方法仅影响该特定子类的行为。其他同样继承自同一个父类的子类不受影响，除非它们也选择覆盖该静态方法。

```javascript
// 抽象基类 Shape
class Shape {
    // 抽象方法 draw
    draw() {
        throw new Error('Method not implemented.');
    }

    // 工厂方法，具体子类需要实现
    static createShape() {
        throw new Error('Method not implemented.');
    }
}

// 具体类 Circle
class Circle extends Shape {
    draw() {
        console.log('Drawing a circle.');
    }

    // 实现工厂方法
    static createShape() {
        return new Circle();
    }
}

// 具体类 Square
class Square extends Shape {
    draw() {
        console.log('Drawing a square.');
    }

    // 实现工厂方法
    static createShape() {
        return new Square();
    }
}

// 使用工厂方法创建形状
const circle = Circle.createShape();
circle.draw(); // 输出 "Drawing a circle."

const square = Square.createShape();
square.draw(); // 输出 "Drawing a square."
```

在这个例子中，`Circle` 和 `Square` 类都继承了 `Shape` 类，并覆盖了 `draw` 方法和 `createShape` 静态方法。通过调用各自类的 `createShape` 方法，我们可以创建出具体的 `Circle` 或 `Square` 对象，而不需要直接使用 `new` 关键字和构造函数。

这种模式的优点在于，如果我们需要添加新的图形类型，我们只需要创建一个新的图形类，继承 `Shape` 类并实现相应的工厂方法，而不需要修改现有的代码。这遵循了开闭原则，即软件实体应该对扩展开放，对修改关闭。



#### 抽象工厂

我们将创建一个抽象工厂来生成不同类型的汽车。首先，我们定义一个抽象基类 `Car`，然后创建具体的汽车子类如 `BMW` 和 `Mercedes`。接着，我们定义一个 `CarFactory` 抽象工厂接口，并实现两个具体工厂 `LuxuryCarFactory` 和 `SportsCarFactory`。

```javascript
// 抽象产品基类 Car
class Car {
  constructor(brand, model) {
    this.brand = brand;
    this.model = model;
  }
  getInfo() {
    return `${this.brand} ${this.model}`;
  }
}

// 具体产品 BMW
class BMW extends Car {
  constructor(model) {
    super('BMW', model);
  }
}

// 具体产品 Mercedes
class Mercedes extends Car {
  constructor(model) {
    super('Mercedes', model);
  }
}

// 抽象工厂接口 CarFactory
class CarFactory {
  createCar(model) {
    throw new Error('Method "createCar" must be implemented.');
  }
}

// 具体工厂 LuxuryCarFactory
class LuxuryCarFactory extends CarFactory {
  createCar(model) {
    if (model === 'X5') {
      return new BMW('X5');
    } else if (model === 'SClass') {
      return new Mercedes('SClass');
    } else {
      throw new Error('Model not supported by this factory.');
    }
  }
}

// 具体工厂 SportsCarFactory
class SportsCarFactory extends CarFactory {
  createCar(model) {
    if (model === 'M3') {
      return new BMW('M3');
    } else if (model === 'AMG GT') {
      return new Mercedes('AMG GT');
    } else {
      throw new Error('Model not supported by this factory.');
    }
  }
}

// 使用工厂创建产品
const luxuryFactory = new LuxuryCarFactory();
const sportsFactory = new SportsCarFactory();

const bmwX5 = luxuryFactory.createCar('X5');
console.log(bmwX5.getInfo()); // 输出: BMW X5

const mercedesAMGGT = sportsFactory.createCar('AMG GT');
console.log(mercedesAMGGT.getInfo()); // 输出: Mercedes AMG GT
```

在这个例子中，`CarFactory` 是抽象工厂接口，`LuxuryCarFactory` 和 `SportsCarFactory` 是具体工厂，它们实现了 `createCar` 方法来生产不同的汽车实例。客户代码通过调用工厂方法来获取产品，而不需要知道具体的产品类。这样就达到了解耦的目的，使得增加新的汽车类型或工厂变得容易。

# 行为型模式

> 特点：关注类之间的职责分配和算法的封装，以便于复用和可扩展性

## 观察者模式

在JavaScript中，观察者模式（Observer Pattern）是一种常用的设计模式，它定义了对象间的一种一对多的依赖关系，允许多个观察者对象同时监听某一个主题对象。当主题对象的状态发生改变时，所有登记过的观察者都会收到通知，并根据需要做出相应的处理。

观察者模式通常包含以下几个关键组件：

1. **Subject（主题）**：
   - 主题对象维护了一个观察者列表。
   - 当主题的状态发生改变时，它会遍历观察者列表并调用每个观察者的`update()`方法来通知他们。
2. **Observer（观察者）**：
   - 观察者对象实现了一个`update()`方法，用于接收主题的通知。
   - 观察者可以订阅多个主题，并且当主题状态改变时，观察者会自动被通知。

观察者模式可以进一步细分为两种类型：

- **Push（推送）**：在推送模型中，主题不仅通知观察者状态发生了变化，还会直接发送新状态的数据。这意味着观察者不需要主动去获取数据。
- **Pull（拉取）**：在拉取模型中，主题仅通知观察者状态发生了变化，而不发送数据。观察者需要主动查询主题以获取最新状态。

在JavaScript中，观察者模式可以非常灵活地实现，常见的实现方式包括使用事件监听器，或者自定义实现Subject和Observer接口。

下面是一个简单的JavaScript观察者模式实现示例：

```javascript
class Subject {
    constructor() {
        this.observers = [];
    }

    addObserver(observer) {
        this.observers.push(observer);
    }

    removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index !== -1) {
            this.observers.splice(index, 1);
        }
    }

    notify(data) {
        this.observers.forEach(observer => observer.update(data));
    }
}

class Observer {
    update(data) {
        console.log(`Observer received data: ${data}`);
    }
}

const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.addObserver(observer1);
subject.addObserver(observer2);

// 模拟状态改变
subject.notify("Hello, Observers!");
```

在这个例子中，`Subject`类维护了一个观察者列表，并提供了添加和移除观察者的方法以及一个`notify`方法来发送通知。`Observer`类则实现了一个`update`方法，当接收到通知时，会打印出接收到的数据。

观察者模式在JavaScript中特别适用于事件驱动的应用，如DOM事件监听、异步请求的处理等场景。
