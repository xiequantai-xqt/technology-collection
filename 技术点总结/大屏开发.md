# 高德地图

## 效果图以及代码

地图效果图：

![](https://super-note.oss-cn-shenzhen.aliyuncs.com/%E5%89%8D%E7%AB%AF/Snipaste_2024-05-30_15-48-38.png)

整体代码：

```vue
<template>
  <div id="mapEcharts" style="width: 100%;height: 600px;"></div>
</template>

<script>
  export default {
    name: 'MapView',
    mounted() {
      this.draw();
    },
    methods:{
      draw(){
        // 初始化地图
        var map = new AMap.Map('mapEcharts', {
            zoom: 8, // 初始地图级别
            center: [116.39,39.9], // 地图中心点坐标
        });

        // 示例点数据
        var points = [
            [116.41,40.92],
            [116.42,39.91],
        ];

        // 定义一个全局变量来保存当前打开的信息窗口，以便在鼠标移出时关闭
        let currentInfoWindow = null;
        // 在地图上添加散点并绑定事件
        points.forEach((point,index) => {
          const marker = new AMap.Marker({
            position: point,
          });
          marker.setMap(map);
          // 绑定mouseover事件
          AMap.Event.addListener(marker, 'mouseover', () => {
            // 如果之前有打开的信息窗口，先关闭它
            if (currentInfoWindow) {
              currentInfoWindow.close();
            }
            
            // 创建新的信息窗口
            const infoWindow = new AMap.InfoWindow({
              content: `<div style="background-color: white;">这是第${index + 1}个点的详细信息</div><br>454`,
              offset: new AMap.Pixel(0, -30), // 设置信息窗口偏移量
            });
            
            // 打开信息窗口
            infoWindow.open(map, marker.getPosition());
            currentInfoWindow = infoWindow; // 更新当前信息窗口引用
          });

          // 绑定mouseout事件以关闭信息窗口
          AMap.Event.addListener(marker, 'mouseout', () => {
            if (currentInfoWindow) {
              currentInfoWindow.close();
              currentInfoWindow = null;
            }
          });
        });
    }
  }
}
</script>

<style scoped>
</style>
```

## 注意

### 监听事件的写法

- 如果是引入了高德地图的2.0版本，Event是大写，`AMap.Event.addListener`

- 如果是引入了高德地图的1.4版本，event是小写，`AMap.event.addListener`

### 地图样式

与百度地图不同，高德地图是在控制台配置上去的，发布完自定义地图，在代码里定义一个id，样式自动更新。



**第一步，配置地图**

配置地图的步骤：

1. 访问高德地图开放平台的官网：https://lbs.amap.com/
2. 登录你的高德地图账号。
3. 在顶部导航栏中找到“开发工具”或“开发者工具”，通常在页面的右上角。
4. 在“开发工具”下拉菜单中选择“自定义地图样式”或类似的选项。
5. 这里你应该能看到地图样式编辑器，可以创建、编辑和管理你的自定义地图样式。

> 如果你仍然找不到入口，建议直接在高德地图开放平台的首页搜索“自定义地图样式”或查看官方文档，以获取最新的接入指南。同时，确保你拥有有效的高德地图开发者账号，因为一些高级功能可能需要付费或申请权限。



**第二步，引入安全密钥**

```html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <div id="app"></div>
    <!-- 安全密钥 -->
    <script>
      window._AMapSecurityConfig = {
        securityJsCode: 'aa6d5d2d1b665c87f77869e3d9371ce8'
      };
    </script>
    <script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&key=ab0cf27461eccdad490ccc839563c368"></script>
  </body>
</html>
```

# 订单自动滚动

![](https://super-note.oss-cn-shenzhen.aliyuncs.com/%E5%89%8D%E7%AB%AF/Snipaste_2024-05-30_15-33-44.png)

刚进入页面时执行一次：

```javascript
_initMethod: function () {
      // 订单
      vc.component.fetchOrderList()
}
```

每隔3分钟刷新一次订单：

```javascript
_initEvent:function(){
    // 3分钟刷新一次订单
  setInterval(() => {
    vc.component.fetchOrderList()
  }, 180000);
}
```

定义fetchOrderList函数（获取订单数据）：

```javascript
// 获取订单数据
  fetchOrderList(){
    vc.http.apiPost(
      "/chargingInvoiceInfo.chargingScreenOrderListCmd",
      JSON.stringify({
        memberId:vc.getData("/nav/getUserInfo").memberId,
        "page": 1, 
        "row": 9999
      }),
      {
        emulateJSON: true,
      },
      function (json, res) {
        var resData = JSON.parse(json);
        if(resData.code === 0){
          // console.log(Math.ceil(resData.data.length/3));
          $that.screenOrderList = []

          $that.screenOrderList = resData.data.map(item=>({
            ...item,
            address: item.address?item.address.slice(0,10):''
          }))
          let INTERVAL_ORDER = setInterval(() => {
            requestAnimationFrame(function(){
              vc.component.autoScroll()
            })
          }, 1000);
          setTimeout(() => {
            clearInterval(INTERVAL_ORDER)
          }, 180000);
        }
      },
      function (errInfo, error) {
      }
    );
  }
```

自动滚动功能：

```javascript
autoScroll() {
    var ordersContainer = document.getElementsByClassName('orderContainer')[0];
    // 获取当前滚动位置
    var currentScrollTop = ordersContainer.scrollTop;
    // 计算下一个滚动位置，这里简单地向下滚动10像素，可以根据需要调整
    var nextScrollTop = currentScrollTop + 8;
    
    // 如果没有滚动到底部，则继续滚动
    if (nextScrollTop < ordersContainer.scrollHeight - ordersContainer.offsetHeight) {
        ordersContainer.scrollTop = nextScrollTop;
        // 使用setTimeout设置下一次滚动，这里设置为100毫秒，根据需要调整速度
        // setTimeout(() => {
        //   requestAnimationFrame(function(){
        //     vc.component.autoScroll()
        //   })
        // }, 30000);
    } else {
        // 如果滚动到了底部，可以选择回到顶部重新开始，或者停止滚动
        ordersContainer.scrollTop = 0; // 回到顶部
        // 重新启动滚动
        // setTimeout(() => {
        //   requestAnimationFrame(function(){
        //     vc.component.autoScroll()
        //   })
        // }, 30000);
    }
 }
```

# 折线图

![](https://super-note.oss-cn-shenzhen.aliyuncs.com/%E5%89%8D%E7%AB%AF/Snipaste_2024-07-16_10-17-22.png)

```html
<div id="brokenLineGraph" class="brokenLineGraph"></div>
```

逻辑：

```javascript
_initMethod: function(){
    // 获取折线图数据
    vc.component.fetchBrokenLineGraphData()
},
// 获取折线图数据
fetchBrokenLineGraphData(){
  vc.http.apiPost(
    "/chargingInvoiceInfo.chargingOrderStatChartCmd",
    JSON.stringify({
      memberId:vc.getData("/nav/getUserInfo").memberId
    }),
    {
      emulateJSON: true,
    },
    function (json, res) {
      var resData = JSON.parse(json);
      if(resData.code === 0){
        vc.component.BrokenLineGraph = resData.data.chargingCntChart
        setTimeout(() => {
          vc.component.drawBrokenLineGraph()
        }, 1000);
      }
    },
    function (errInfo, error) {
    }
  );
}
```

样式：

```scss
.brokenLineGraph{
    width: calc(25% - 10px);
    height: 25vh;
    background: #001E4C;
    border-radius: 20px;
    margin-left: 10px;
}
```

# 柱状图

![](https://super-note.oss-cn-shenzhen.aliyuncs.com/%E5%89%8D%E7%AB%AF/Snipaste_2024-07-16_10-23-08.png)

```html
<div id="chargeData" class="chargeData"></div>
```

逻辑：

```javascript
_initMethod: function () {
    // 获取本月充电数据
    vc.component.getChargeData();
},
_initEvent:function(){
    // 获取本月充电数据
    setInterval(() => {
      vc.component.getChargeData()
    }, 1800000);
},
// 获取本月充电数据
getChargeData(){
  vc.http.apiPost(
    "/chargingInvoiceInfo.chargingMonthOrderStatCmd",
    JSON.stringify({
      memberId:vc.getData("/nav/getUserInfo").memberId
    }),
    {
      emulateJSON: true,
    },
    function (json, res) {
      var resData = JSON.parse(json);
      if(resData.code === 0){
        vc.component.chargeMonthDataList = resData.data
        vc.component.drawChargeData();
      }
    },
    function (errInfo, error) {
    }
  );
},
// 绘制本月充电数据
drawChargeData() {
  var myChart = echarts.init(document.getElementById('chargeData'));
  var option = {
      tooltip: {
          trigger: 'axis',
          axisPointer: {
              type: 'shadow'
          }
      },
      legend: {
          data: ['充电桩数', '充电量（度）'],
          textStyle: { // 修改图例文字样式
            color: '#07FEFF' // 设置图例文字颜色
        },
        x: 'right', // 设置图例靠右，水平方向靠右对齐
        top:5
      },
      grid: {
          left: '3%',
          right: '4%',
          bottom: '3%',
          containLabel: true,
          show: false, // 可选，隐藏网格线以更贴近你的需求
          width:'80%'
      },
      xAxis: {
          type: 'value',
          boundaryGap: [0, 0.01],
          axisLabel: { // x轴标签样式设置
            color: '#ffffff', // 设置x轴字体颜色为白色
        },
        // axisLine: {
        //   show: false,
        //   lineStyle: {
        //     color: '#000000'
        //  }
        // }
      },
      yAxis: {
          type: 'category',
          data: $that.chargeMonthDataList.map(item=>item.address),
          axisTick: {
              show: false // 可选，不显示y轴刻度线
          },
          inverse: true,// 使y轴标签从下往上排列
          axisLabel: {
            formatter: function (value) {
                // 使用rich配置来自定义颜色
                return '{color1|' + value + '}';
            },
            rich: {
                color1: {
                    color: '#07FEFF',
                    fontSize: 14 // 如果需要，还可以调整字体大小
              }
            }
          },
        //   axisLine: {
        //     show: false,
        //     lineStyle: {
        //         color: '#000000'
        //   }
        // }
      },
      series: [
          {
              name: '充电桩数',
              type: 'bar',
              barWidth: '30px',
              data: $that.chargeMonthDataList.map(item=>item.chargingCnt),
              label: {
                  show: true, // 显示柱子上的数值标签
                  position: 'right' // 数值标签位置设为右侧
              },
              color: '#5069FF' // 设置充电数柱子的颜色
          },
          {
              name: '充电量（度）',
              type: 'bar',
              barWidth: '30px',
              data: $that.chargeMonthDataList.map(item=>item.actualDegree),
              label: {
                  show: true,
                  position: 'right'
              },
              color: '#E3BA6A' // 设置充电量柱子的颜色
          }
      ]
  };
  myChart.setOption(option);
},
```

样式：

```css
.chargeData{
    width: 408px;
    height: 43vh;
    background-color: #001e4c;
    padding: 10px;
    border-radius: 20px;
    margin-top:20px;
}
```

# SSE

## 什么场景下使用SSE？

1. **实时数据展示**： 如果大屏需要实时展示从服务器端获取的数据，比如股票价格、传感器数据、实时分析数据或物联网设备的状态更新，SSE 可以实现实时推送这些数据到客户端，而无需客户端频繁地轮询服务器。
2. **低延迟数据更新**： SSE 提供了较低的延迟数据传输方式，这对于需要及时更新信息的大屏应用非常有用。例如，在监控系统中，可能需要快速反应最新的警报或事件。
3. **单向数据流**： 当大屏应用只需要接收数据而不发送数据到服务器时，SSE 是一个很好的选择。这是因为 SSE 设计为单向通信，即服务器到客户端的数据推送。
4. **资源限制环境**： 对于资源受限的环境，如移动设备或某些嵌入式系统，SSE 可能比 WebSocket 更节省资源，因为它使用 HTTP 协议，可以更容易地通过现有的代理和防火墙。
5. **简单部署和维护**： SSE 相对容易实现和维护，因为它使用标准的 HTTP 连接，不需要像 WebSocket 那样设置特殊的握手协议。

然而，SSE 也有一些局限性，例如：

- **单向通信**：它只支持从服务器到客户端的数据流，如果需要双向通信，则应考虑使用 WebSocket。
- **浏览器兼容性**：尽管现代浏览器广泛支持 SSE，但在一些旧版或特定的浏览器中可能不支持，这可能需要额外的兼容性处理。

## 如何使用SSE？

原理：主要涉及创建一个`EventSource`对象并监听其事件。

步骤1: 创建 EventSource 对象

> 首先，你需要创建一个 `EventSource` 对象，传入你的服务器端点URL作为参数。这个URL应该返回SSE格式的数据流。

```javascript
const eventSource = new EventSource('/api/sse-endpoint');
```

步骤2: 监听事件

> 接下来，你需要监听 `message` 事件，这是当服务器推送数据时触发的事件。你也可以监听 `open` 和 `error` 事件来处理连接状态的变化。

```javascript
eventSource.addEventListener('message', function(event) {
    // 解析 event.data，通常它是一个 JSON 字符串
    const data = JSON.parse(event.data);
    
    // 根据数据更新大屏界面
    updateDisplay(data);
});

// 连接打开时触发
eventSource.addEventListener('open', function(event) {
    console.log('SSE connection opened.');
});

// 错误处理
eventSource.addEventListener('error', function(event) {
    if (event.target.readyState === EventSource.CLOSED) {
        console.error('SSE connection closed.');
    } else {
        console.error('SSE error occurred.');
    }
});
```

步骤3: 数据处理与显示

> 在 `message` 事件的回调函数中，你需要解析接收到的数据，并根据数据更新大屏的显示。这通常涉及到将JSON字符串转换为JavaScript对象，然后更新DOM元素。

```javascript
function updateDisplay(data) {
    // 更新DOM元素，例如：
    document.getElementById('sensor-value').innerText = data.value;
}
```

步骤4: 关闭 EventSource

> 在不再需要接收数据时，记得关闭 `EventSource` 对象以释放资源。

```javascript
eventSource.close();
```

完整示例代码

```javascript
// 创建 EventSource 对象
const eventSource = new EventSource('/api/sse-endpoint');

// 监听 'message' 事件
eventSource.addEventListener('message', function(event) {
    const data = JSON.parse(event.data);
    updateDisplay(data);
});

// 连接打开时触发
eventSource.addEventListener('open', function(event) {
    console.log('SSE connection opened.');
});

// 错误处理
eventSource.addEventListener('error', function(event) {
    if (event.target.readyState === EventSource.CLOSED) {
        console.error('SSE connection closed.');
    } else {
        console.error('SSE error occurred.');
    }
});

// 数据处理与显示
function updateDisplay(data) {
    document.getElementById('sensor-value').innerText = data.value;
}

// 关闭 EventSource
// 在适当的时机调用
eventSource.close();
```

确保你的服务器端正确设置了SSE格式的数据流，通常是以 `text/event-stream` 的Content-Type进行响应，并且每条数据都以 `data:` 开头，后跟数据内容。

