# 一、CSS选择器与优先级？

CSS选择器：

1. **通配选择器 (`\*`)**：匹配文档中的所有元素。优先级最低。
2. **标签选择器**：直接使用HTML元素名称（如 `div`, `p`, `h1` 等）来选择相应的元素。
3. **类选择器**：以点号 (`.`) 开头，后跟类名（如 `.main`, `.highlight`）。用于选择具有指定类属性的元素。
4. **属性选择器**：根据元素的属性及属性值来选择元素，如 `[type="text"]` 选择所有 `type` 属性为 `"text"` 的元素。
5. **ID选择器**：以井号 (`#`) 开头，后跟ID名（如 `#header`, `#content`）。用于选择具有指定ID属性的元素。
6. **伪类**：用于根据元素状态（如 `:hover`, `:focus`）或结构位置（如 `:first-child`, `:nth-of-type()`）选择元素。
7. **伪元素**：用于选择元素的特定部分或创建虚拟元素，如 `::before`, `::after`, `::first-letter`。
8. **内联样式**：通过HTML元素的 `style` 属性直接定义在元素上的样式。

优先级：

1. **内联样式** (`style` 属性定义的样式)：最高优先级。
2. **ID选择器** (`#id`)：基于元素ID的独特性，具有很高的优先级。
3. **类选择器、属性选择器和伪类** (`.`class, `[attr]`, `:pseudo-class`)：中等优先级。
4. **标签选择器和伪元素** (`element`, `::pseudo-element`)：较低优先级。
5. **通配选择器 (`\*`)** 和 **继承**：优先级最低。

# 二、隐藏元素的方法？

1. **display: none**：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
2. **visibility: hidden**：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
3. **opacity: 0**：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
4. **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
5. **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。
6. **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
7. **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

# 三、link和@import的区别？

两者都是外部引用CSS的方式，它们的区别如下：

1. link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
4. link支持使用Javascript控制DOM去改变样式；而@import不支持。

# 四、transition和animation的区别？

- **transition是过度属性**，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。
- **animation是动画属性**，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。

# 五、display:none与visibility:hidden的区别？

1. **空间占用**:
   - **display:none**: 元素不仅视觉上不可见，而且在页面布局中不占用任何空间。这意味着该元素就像是完全从DOM中移除一样，不会影响周围元素的位置和布局。
   - **visibility:hidden**: 元素视觉上不可见，但在页面布局中仍然保留其原有空间。周围的元素不会因为这个元素隐藏而重新排列，就像元素在那里，只是透明了一样。
2. **渲染过程**:
   - **display:none**: 不会参与页面的渲染过程，也就是说在生成渲染树（Render Tree）时，该元素不会被包含进去。这导致不会进行元素的绘制和布局计算，从而节省了渲染性能。
   - **visibility:hidden**: 仍然参与渲染过程，会被加入到渲染树中，进行布局计算，但它在绘制阶段被标记为不可见。因此，虽然内容不可见，但浏览器仍需计算其位置和大小。
3. **对事件的影响**:
   - **display:none**: 隐藏的元素不会接收到任何用户交互事件，如鼠标悬停或点击。
   - **visibility:hidden**: 元素虽然不可见，但仍能接收用户交互事件，因为它在布局中仍然存在。

# 六、伪元素和伪类的区别和作用？

伪类：

- **作用**：伪类用于选择元素基于用户行为或特定状态的样式，例如，`:hover` 用于当鼠标悬停在元素上时改变样式，`:active` 用于激活（如点击）状态，`:visited` 用于访问过的链接等。它们描述的是元素的动态状态，而非实际的DOM结构。
- 特点：
  - 可以应用于任何元素。
  - 可以同时使用多个伪类于同一元素上。
  - 它们代表元素生命周期中的某个特定状态。

伪元素：

- **作用**：伪元素用于创建或修饰元素的某些部分，这些部分在文档树中并不存在，如为元素添加装饰性的前后内容（如首行、首字、前后插入内容等）。常见的伪元素有 `::before`, `::after`, `::first-line`, `::first-letter` 等。
- 特点：
  - 在页面中并不真实存在，是通过CSS生成的。
  - 每个元素最多只能同时使用一个指定类型的伪元素（如一个`::before`和一个`::after`）。
  - 通过 `content` 属性来定义伪元素的内容。
  - 它们用于样式化元素的特定部分或添加额外的装饰内容。

# 七、对盒模型的理解？

CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型。

- **标准盒模型（W3C盒模型）**： 在标准盒模型中，`width`和`height`仅指内容区域的尺寸。边框和内边距是在内容区域之外额外增加的，因此，一个元素的总宽度或高度等于内容宽度/高度加上左右内边距、上下内边距、左右边框宽度和上下边框宽度。
- **IE盒模型（怪异盒模型）**： 使用特定CSS声明（如`box-sizing: border-box;`）的情况下，`width`和`height`包括内容区域、内边距和边框的宽度。这意味着设置的宽度或高度是元素的总宽度，内边距和边框不会进一步增加元素的总尺寸。

# 八、CSS 优化和提高性能的方法有哪些？

1. **合并CSS文件**：将多个CSS文件合并成一个文件，减少HTTP请求的数量，从而加快页面加载速度。
2. **压缩CSS代码**：使用自动化工具（如CSS Nano、UglifyCSS）去除空格、注释、缩短选择器和属性名，减小CSS文件的大小。
3. **使用外部CSS文件**：相比于内联样式，外部CSS文件可以被浏览器缓存，减少后续页面加载的资源请求。
4. **避免使用@import**：`@import`会导致额外的HTTP请求，并且会阻塞页面渲染直到CSS文件加载完毕。使用 `<link>` 标签代替。
5. **减少选择器的复杂度**：简化CSS选择器，避免过深的嵌套和不必要的组合，因为复杂的CSS选择器会影响渲染性能。
6. **利用继承和层叠**：合理利用CSS的继承特性，减少重复定义样式。利用层叠规则，避免过度使用ID选择器和!important声明。
7. **使用CSS预处理器**（如Sass、Less）：它们可以帮助组织和维护CSS代码，同时通过编译过程自动优化代码。
8. **媒体查询优化**：将媒体查询放在样式表的底部，或拆分成独立的文件，确保非匹配的查询不会阻塞渲染。
9. **利用CSS变量**（Custom Properties）：减少重复值，便于维护和修改，同时现代浏览器对CSS变量的解析效率较高。
10. **懒加载CSS**：对于非首屏内容，可以延迟加载对应的CSS文件，优先加载关键CSS，提升首屏加载速度。
11. **避免使用CSS表达式**：CSS表达式在页面渲染和每次重绘时都会计算，可能导致性能问题。
12. **监控CSS性能**：使用开发者工具中的性能分析功能，定期检查CSS对页面渲染性能的影响，及时发现并优化瓶颈。

# 九、z-index属性在什么情况下会失效？

- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；

- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；

- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；

# 十、水平垂直居中的实现方式？

## 1. 使用Flexbox（推荐）

Flexbox是现代布局中最简单且强大的方式之一，适用于单一元素或容器内的多个元素居中。

```css
.container {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
  height: 100vh; /* 示例高度，可根据需要调整 */
}
```

## 2. 绝对定位 + 变换（Transform）

适用于已知宽高的固定元素。

```css
.container {
  position: relative;
  height: 100vh; /* 示例高度，可根据需要调整 */
}

.centered-element {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

## 3. 使用 calc() 和 translateY()

适用于动态高度的容器。

```css
.container {
  position: relative;
  height: 100vh; /* 示例高度，可根据需要调整 */
}

.centered-element {
  position: absolute;
  top: calc(50% - /* 元素高度的一半 */);
  left: 50%;
  transform: translateX(-50%);
}
```

# 十一、对BFC的理解，如何创建BFC？

会计格式化上下文定义了一个独立的渲染区域，其中的元素布局不受外界影响，同时也不会影响到外面的元素。

BFC内部的元素会按照一定规则进行排列，具体表现为：

1. **边距折叠**：在BFC内部，相邻的块级元素垂直外边距不会折叠，而在BFC外部，这种情况下的外边距可能会合并。
2. **包含浮动**：BFC可以包含其内部浮动元素，使得浮动元素不会溢出到外部，而是撑开BFC的高度。
3. **布局隔离**：BFC内部元素的布局不会影响到外部元素，反之亦然，提供了某种程度的布局隔离。
4. **块级元素排版**：BFC中的块级元素从顶部开始垂直排列，且块级盒模型的margin不会与浮动元素重叠。

要创建一个新的BFC，可以通过以下任意一种方式：

1. **浮动（float）**：设置元素的 `float` 属性为 `left` 或 `right`。
2. **绝对定位（position）**：将元素的 `position` 属性设置为 `absolute` 或 `fixed`。
3. **overflow**：给元素设置 `overflow` 属性为 `auto`、`hidden` 或 `scroll`（注意：`visible` 不会触发BFC）。
4. **display**：使用 `display: flow-root`、`display: flex`、`display: grid` 或 `display: inline-block` （当元素不是浮动元素也不是绝对定位元素时）。

创建BFC常常用于解决布局问题，如清除浮动、防止外边距折叠等。