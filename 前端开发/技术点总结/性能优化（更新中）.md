# 静态资源优化

1. 减少http请求

   1. **合并文件**：通过合并CSS、JavaScript文件和使用雪碧图（Sprites）等方式减少向服务器发送的请求数量。

   2. **使用Sprite技术**：将小图标合并到一张大图中，通过CSS背景定位来显示不同的图标，从而减少请求次数。

2. **使用CDN（内容分发网络）**：将静态资源部署在CDN上，通过CDN分发静态资源，可以减轻服务器负载并加快资源加载速度。

3. 压缩资源
   1. **压缩HTML、css、JavaScript**：移除不必要的空格、换行符和注释，减小文件大小。
   2. **使用Gzip压缩**：服务器端启用Gzip压缩，对文件压缩能大大提高首屏加载速度，对于纯文本文件我们可以至少压缩到原大小的40%，图片不要开启gzip压缩，因为压缩效果不明显。
4. **SSR服务端渲染**：它指的是渲染过程在服务端完成，最终的渲染结果 HTML 页面通过 HTTP 协议发送给客户端，又叫“同构“。SSR主要带来的好处就是 SEO 和首屏加载速度大大提高。

# 接口访问优化

1. 减少不必要的API调用：确保只请求需要的数据，避免冗余请求。
2. 缓存策略
   1. **浏览器缓存**：设置适当的HTTP缓存控制头（如`Expires`和`Cache-Control`），让浏览器重复利用已缓存的资源。
   2. **服务端缓存**：对于动态生成的内容，利用服务端缓存机制减少不必要的数据库查询。

# 打包优化

1. webpack优化resolve.alias配置（vite同理）

`resolve.alias` 配置通过别名来将原导入路径映射成一个新的导入路径。 可以起到两个作用：1.起别名；2.减少查找过程。

例如：

```json
resolve: {
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
    }
  }
```

2. webpack优化resolve.extensions配置（vite同理）

`resolve.extensions` 代表后缀尝试列表，它也会影响构建的性能，默认是：`extensions: ['.js', '.json']`。

后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中，频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。

```json
resolve: {
    extensions: ['.js', '.vue', '.json'],
}
```

3. webpack缩小loader范围

loader是很消耗性能的一个点，我们在配置loader的时候，可以使用include和except来缩小loader执行范围，从而优化性能。 例如：

```json
{
    test: /\.svg$/,
    loader: 'svg-sprite-loader',
    include: [resolve('src/icons')]
 }
```

4. tree shaking

用来清除我们项目中的一些无用代码，它依赖于ES中的模块语法得以实现。`tree shaking`可以大大减少包体积，是性能优化中的重要一环。 在 vite 和 webpack4.x 中都已经默认开启tree-shaking。

5. vite关闭一些打包配置项

```json
build: { 
      terserOptions: {
        compress: {
          //生产环境时移除console
          drop_console: true,
          drop_debugger: true,
        },
      },
      //关闭文件计算
      reportCompressedSize: false,
      //关闭生成map文件 可以达到缩小打包体积
      sourcemap: false, // 这个生产环境一定要关闭，不然打包的产物会很大
}
```

# 代码层面的优化

1. 优化DOM操作（最小化DOM操作）：减少DOM操作次数和复杂度，因为DOM操作是比较耗时的。
2. 事件委托：使用事件代理来减少事件监听器的数量。
3. 避免重排和重绘：减少布局变化，比如避免在循环中修改样式和布局属性。

# 页面渲染速度优化

1. 代码分割
   1. 按需加载：通过Webpack等工具将代码分割成多个小块，并根据需要动态加载。
2. 异步加载
   1. 异步加载CSS和JavaScript：移除不必要的空格、换行符和注释，减小文件大小。
   2. 插件按需加载：npm插件按需加载。
   3. 组件异步加载

```javascript
// 1. import懒加载
() => import('@/pages/xxx.vue')
// 2. 使用require
resolve => require(['@/pages/xxx.vue'], resolve)
```

3. 预加载和预获取

   > 资源预加载包括预连接、资源预渲染等。预加载的思路有两个：
   >
   > 1. 当前将要获取资源的列表；
   > 2. 通过当前页面或者应用状态、用户历史或者session预测用户行为，以及必须的资源；

   1. 预加载关键资源：使用`<link rel="preload">`提前加载关键资源。
   2. DNS预获取：使用`<link rel="dns-prefetch">`提前解析关键域名的DNS记录。



4. 图片加载优化

   1. 响应式图片：使用`<picture>`标签或`srcset`属性来提供不同分辨率的图片版本。

   2. 图片懒加载：只在图片进入视口时才加载图片资源。

> 传统的图片加载方式是在页面加载完成后一次性加载所有图片资源，这样会造成页面加载时间过长，带宽消耗过大，影响用户体验。
>
> 当图片出现在浏览器的可视区域内时，才加载图片让图片显示出来（在此之前可以将所有图片元素的路径全都统一设置成一张1*1px的占位图）。
>
> 判断图片出现在浏览器可视区域的方法：图片距离顶部的高度（offsetTop） - 页面被卷去的高度（scrollTop） <= 浏览器的可视区域的高度（innerHeight）。



图片懒加载的优点：

1. 减少首页加载的时间：初始页面只加载必要内容，而不需要等待所有资源都加载完成。
2. 提高用户体验：页面每次加载都只是加载一部分资源，加载更快，用户可以更快地交互和浏览内容。
3. 节约带宽消耗：只加载用户需要的内容，减少不必要的带宽消耗。



懒加载如何实现：

1. 判断图片是否已经进入可视区域范围
2. 图片进入可视区域后，触发加载图片

