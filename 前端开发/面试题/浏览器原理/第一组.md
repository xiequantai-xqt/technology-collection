# 一、什么是 XSS 攻击？

XSS是一种常见的网络安全漏洞，它允许攻击者在目标用户的浏览器中注入恶意脚本代码。这些恶意脚本能够执行攻击者设计的各种操作，从而影响受害用户的隐私和安全。XSS攻击的核心在于利用Web应用程序对用户输入数据处理不当，未能有效过滤或转义特殊字符，使得攻击者能够注入可执行的HTML或JavaScript代码。

XSS攻击的分类及特点：

1. **反射型XSS（非持久性XSS）**：
   - 攻击者通过构造包含恶意脚本的URL，并诱导用户点击该链接。
   - 恶意脚本作为请求的一部分发送到服务器，服务器未经检查直接将脚本返回到用户的浏览器中执行。
   - 这种类型的XSS不持久存储在服务器上，仅在用户访问特定链接时触发。
2. **存储型XSS（持久性XSS）**：
   - 攻击者提交含有恶意脚本的数据到服务器，如论坛留言、用户资料等。
   - 服务器将这些数据存储下来，并在其他用户访问相关页面时，无差别地展示这些包含恶意脚本的内容，导致攻击脚本在多个用户浏览器中执行。
   - 这种类型的XSS具有持久性，只要恶意内容未被清除，任何访问该页面的用户都可能受到攻击。
3. **DOM-based XSS**：
   - 不涉及服务器端数据存储或响应，而是利用网页的JavaScript代码处理用户输入不当。
   - 攻击发生在客户端，通过修改DOM（文档对象模型）来插入恶意脚本，当浏览器解析修改后的DOM时执行恶意代码。
   - 由于完全在客户端发生，即使服务器端有安全措施，也可能发生DOM-based XSS。

XSS攻击的危害：

- **窃取用户数据**：如cookies、session令牌等，进而进行身份冒充或信息窃取。
- **操纵页面内容**：修改页面显示，误导用户，进行钓鱼攻击。
- **传播恶意软件**：通过脚本引导用户下载或执行恶意软件。
- **执行恶意操作**：在用户不知情的情况下，代表用户执行操作，如发送邮件、进行交易等。

防御措施：

- 对用户输入的数据进行严格的输入验证和输出编码。
- 使用HTTP头部的Content-Security-Policy（CSP）来限制外来的脚本执行。
- 实施同源政策（Same-Origin Policy）和Cookie的安全属性（如HttpOnly标志）来降低风险。
- 对动态生成的内容使用安全的编程模式，避免DOM操作中的注入风险。

# 二、什么是 CSRF 攻击？

CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种网络攻击方式，它利用用户在已登录网站的合法身份，诱导用户在不知情的情况下执行攻击者预设的操作。这种攻击的关键在于，浏览器会自动携带用户在目标网站的有效cookie和其他认证信息，向该网站发送请求，即使请求是从第三方恶意站点发起的。

CSRF攻击的特点与过程：

1. **利用信任关系**：攻击者利用受害者对受信任网站的信任，以及浏览器自动发送认证凭据（如Session Cookie）的机制。
2. **无须窃取密码**：与XSS或其它攻击不同，CSRF并不直接窃取用户的账号密码，而是利用用户已有的登录状态。
3. **用户无感知**：受害者往往在完全不知情的情况下参与了攻击，可能只是点击了一个链接或提交了一个表单。
4. **攻击链路**：攻击者通常会构建一个恶意链接或表单，诱导用户在浏览器中触发。一旦用户触发，浏览器就会带着该网站的有效cookie向服务器发送请求，执行攻击者期望的操作，如转账、修改密码等。

防御措施：

- **Token验证**：服务器在表单或Ajax请求中加入一个随机生成的、一次性使用的token，用户提交请求时必须携带此token，服务器验证token有效性后才处理请求。
- **Referer检查**：检查HTTP请求头中的Referer字段，确保请求是从预期的源站点发起的，但这种方法并非绝对安全，因为Referer可以被伪造或某些情况下不可用。
- **SameSite Cookie属性**：设置Cookie的SameSite属性为Lax或Strict，可以一定程度上防止跨站请求携带Cookie。
- **双重认证**：对于敏感操作，增加一层用户交互验证，如短信验证码、二次密码等。
- **用户教育**：提高用户对不信任来源链接的警惕性，减少点击风险。

# 三、进程与线程的概念？

进程（Process）概念：

1. **定义**：进程是操作系统进行资源分配和调度的基本单位，它是程序执行的一个实例。每个进程都有独立的内存空间，包括代码段、数据段、堆和栈，以及各自的系统资源，如文件描述符、信号处理器等。
2. **特征**：
   - **独立性**：进程之间相互独立，一个进程崩溃不会直接影响其他进程。
   - **资源拥有**：每个进程都拥有独立的系统资源，包括内存、打开的文件等。
   - **上下文切换**：操作系统在进程之间切换执行时，需要保存和恢复进程的上下文信息，如寄存器状态等。

线程（Thread）概念：

1. **定义**：线程是进程内的执行单元，是CPU调度的最小单位。一个进程可以包含多个线程，这些线程共享该进程的内存空间和资源。
2. **特征**：
   - **轻量级**：相比于进程，线程创建和切换的开销较小。
   - **共享资源**：同一进程内的线程可以直接访问该进程的内存和资源，无需进行进程间通信。
   - **并发执行**：线程使得程序能够在同一进程中实现并发执行，提高执行效率和响应速度。
   - **独立执行路径**：尽管线程共享资源，但每个线程有自己的程序计数器、栈空间，可以独立执行不同的任务。

进程与线程的关系：

- **包含关系**：一个进程可以包含一个或多个线程，主线程通常负责初始化工作，其他线程则是根据需要创建的。
- **资源分配**：进程是资源分配的基本单位，而线程是CPU调度的基本单位。
- **通信成本**：由于线程共享同一进程的内存空间，线程间的通信相对简单，而进程间通信需要通过IPC（进程间通信）机制，成本较高。

综上所述，进程提供了应用程序执行的环境和资源隔离，而线程则是在进程内部实现并发执行的机制，两者共同支撑了现代操作系统中的多任务处理能力。

# 四、进程和线程的区别？

1. **资源分配与隔离**：
   - **进程**：是操作系统资源分配的基本单位，每个进程都拥有独立的内存空间，包括代码、数据、堆栈等，以及独立的系统资源，如文件描述符和信号处理器。进程之间相互隔离，不能直接访问彼此的内存，保证了数据的安全性和程序的独立运行环境。
   - **线程**：线程是进程内部的一个执行单元，多个线程共享所属进程的内存空间和资源，包括全局变量和文件描述符。这意味着线程之间可以直接访问相同的地址空间，提高了通信效率，但同时也需要注意同步和互斥问题，以避免数据竞争和不一致性。
2. **调度与控制**：
   - **进程**：作为资源拥有单位，进程是重量级的，创建和销毁进程需要较大的系统开销，且进程之间的切换（上下文切换）也较为耗时。
   - **线程**：作为CPU调度的基本单位，线程更加轻量级，创建、销毁和切换线程的开销相对较小，因此线程能更高效地实现并发执行。
3. **并发与并行**：
   - 无论是进程还是线程，都支持并发执行，即在宏观上看起来同时进行。在多核处理器系统中，线程还能够实现并行执行，即物理上同时在多个处理器上执行。
4. **通信**：
   - **进程间通信**（IPC）通常需要通过操作系统提供的特殊机制，如管道、消息队列、共享内存等，通信成本较高。
   - **线程间通信**则因为共享同一地址空间，可以直接读写同一块内存区域，或者使用更轻量级的同步原语（如互斥锁、信号量）来协调，通信更为简便快捷。
5. **适用场景**：
   - 进程适用于需要高度隔离、保护资源不被其他程序干扰的场景，或在不同程序间需要进行数据交换时。
   - 线程更适合需要高效并发处理、资源共享和快速响应的场景，如多任务处理、并行计算等。

# 五、对浏览器的缓存机制的理解？

浏览器缓存的全过程：

1. **用户请求**： 用户在浏览器中输入URL或点击链接，发起HTTP请求。
2. **检查强缓存**：
   - 浏览器首先查看本地缓存，检查是否有请求的资源。
   - 如果资源存在并且未过期（根据`Cache-Control`或`Expires`头），浏览器直接从缓存中加载，不需要与服务器通信（称为命中强缓存）。
3. **协商缓存**：
   - 如果资源在强缓存中不存在或已过期，浏览器会继续向服务器发送请求，但这次请求带有`If-Modified-Since`或`If-None-Match`头。
   - `If-Modified-Since`：浏览器发送资源的最后修改时间，询问服务器是否在该时间后进行了修改。
   - `If-None-Match`：浏览器发送资源的ETag（实体标记），询问服务器当前的ETag是否相同。
4. **服务器响应**：
   - 服务器检查这些头，如果资源未被修改，则返回304 Not Modified状态码，不携带资源内容。
   - 如果资源已修改，服务器会返回200 OK状态码，并附带新的资源内容以及更新的`Last-Modified`或`ETag`头。
5. **更新缓存**：
   - 如果服务器返回200状态码，浏览器会将新资源存入缓存，并更新对应的缓存控制信息。
   - 如果服务器返回304状态码，浏览器使用本地的旧资源，但也会更新过期时间或ETag。
6. **返回资源**：
   - 浏览器将从服务器收到的新资源或确认可用的旧资源呈现给用户。
7. **缓存策略的调整**：
   - 开发者可以通过设置HTTP响应头（如`Cache-Control`、`Pragma`、`Expires`等）来控制资源的缓存行为，例如设置缓存有效期、禁止缓存或者强制验证。

# 六、协商缓存和强缓存的区别？

**强缓存**：浏览器根据`Cache-Control`或`Expires`头判断资源是否过期，若未过期，直接从缓存加载，不与服务器通信。

**协商缓存**：如果资源过期，浏览器会发送请求到服务器，通过`If-Modified-Since`或`If-None-Match`头询问资源是否更新。若未更新，服务器返回304状态码，使用本地缓存；若更新，服务器返回200和新资源。

主要区别在于：强缓存不与服务器交互，协商缓存需服务器验证。

# 七、浏览器的渲染过程？

1. **解析HTML构建DOM树**：
   - 浏览器接收到HTML文档后，首先通过HTML解析器（HTML Parser）将其解析成一系列的DOM（Document Object Model）节点，形成一颗DOM树。DOM树是一个结构化的文档表示，反映了文档的元素结构和关系。
2. **解析CSS生成CSSOM树**：
   - 同时，浏览器解析外部CSS文件和内联样式，通过CSS解析器（CSS Parser）构建CSSOM（CSS Object Model）树。CSSOM树描述了CSS规则以及它们之间的继承关系和优先级。
3. **合并DOM与CSSOM形成Render Tree（渲染树）**：
   - 接下来，DOM树和CSSOM树合并，生成Render Tree（渲染树）。渲染树只包含需要渲染的元素和它们的样式信息，不可见元素（如`display: none`）不会被包含在内。
4. **布局（Layout）**：
   - 浏览器根据Render Tree计算每个节点的几何信息，即位置和尺寸，这一过程称为布局或重排（reflow）。布局是一个递归过程，从根节点开始，计算每一层子节点的位置和尺寸。
5. **绘制（Painting）**：
   - 最后，浏览器根据布局信息，通过图形库（如Skia, Cairo）将各个节点绘制到屏幕上。这一过程称为绘制或渲染（repaint）。绘制是将颜色、形状等视觉信息填充到布局好的位置上。
6. **合成（Compositing）**（可选步骤）：
   - 对于复杂的页面，为了优化性能，浏览器可能将页面分成多个图层，每个图层独立绘制，最后通过合成器（Compositor）将这些图层合并成最终的页面。这样，当页面发生变化时，只需重新绘制和合成受影响的图层，而不是整个页面。
7. **重绘与回流**：
   - 在页面响应用户交互或样式变化时，可能触发重绘（仅颜色或背景改变）或回流（元素尺寸、位置或结构变化），导致部分或全部渲染过程重新执行。

# 八、浏览器渲染优化？

1. **减少重排（reflow）和重绘（repaint）**：
   - 避免不必要的DOM操作，特别是那些可能导致父元素及其后代元素布局改变的操作。
   - 使用CSS3的`transform`和`opacity`属性进行动画，因为这些属性可以触发合成器，而不是布局和绘制。
   - 使用`requestAnimationFrame`来平滑动画，确保在浏览器准备好绘制下一帧时才执行。
2. **最小化DOM大小**：
   - 减少DOM节点数量，降低遍历和操作DOM的成本。
   - 使用模板库或虚拟DOM技术来减少实际DOM操作。
3. **CSS优化**：
   - 使用CSS选择器的最佳实践，避免使用复杂的和低效的选择器。
   - 将CSS内联到HTML中，或者使用`<link>`标签并放在`<head>`中，以便尽早下载和应用样式。
   - 使用媒体查询进行移动端优化，按需加载资源。
4. **JavaScript优化**：
   - 避免阻塞渲染的JavaScript，尤其是在`<head>`中，应将脚本放在`<body>`底部，或使用`async`或`defer`属性。
   - 使用事件委托减少事件监听器的数量。
   - 减少全局变量的使用，以降低内存占用和垃圾回收压力。
5. **资源优化**：
   - 使用HTTP/2以减少网络请求，因为它支持多路复用。
   - 使用图片压缩工具减小图片大小，考虑使用WebP或SVG等更高效的格式。
   - 利用CDN（内容分发网络）加速静态资源的加载。
   - 使用懒加载（lazy loading）延迟非首屏内容的加载。
6. **利用缓存**：
   - 设置合适的HTTP缓存头，如`Cache-Control`和`Expires`，利用浏览器的缓存机制。
   - 使用Service Worker进行离线缓存和预加载。
7. **代码分割和异步加载**：
   - 分割大型JavaScript文件，按需加载模块。
   - 使用动态导入(`import()`)加载非关键路径的代码。
8. **首屏优化**：
   - 使用服务器端渲染（SSR）或预渲染（Prerendering）来加速首次加载。
   - 优先加载首屏内容，如使用骨架屏或占位符。
9. **性能监控和分析**：
   - 使用开发者工具的性能面板进行性能分析，找出瓶颈并针对性优化。
   - 利用Lighthouse等自动化工具进行性能审计。

# 九、Cookie、LocalStorage、SessionStorage区别？

1. **存储位置**：
   - **Cookie**：存储在客户端（浏览器），每次HTTP请求都会自动发送给服务器（对于同源策略）。
   - **LocalStorage**：存储在客户端，不会随HTTP请求发送到服务器，除非通过特定API。
   - **SessionStorage**：类似于LocalStorage，也存储在客户端，但仅限于单个浏览会话，浏览器关闭后数据清除。
2. **生命周期**：
   - **Cookie**：可以通过设置过期时间，通常较长，但默认情况下浏览器关闭后清除。
   - **LocalStorage**：数据永久存在，除非被删除，否则不会自动清除。
   - **SessionStorage**：数据仅在当前浏览器会话期间有效，浏览器关闭后数据自动清除。
3. **数据大小**：
   - **Cookie**：通常限制在4KB左右。
   - **LocalStorage**和**SessionStorage**：通常可以存储5MB或更大的数据，具体大小取决于浏览器。
4. **安全性**：
   - **Cookie**：可以设置安全标志（secure flag）和HTTP-only标志，防止JavaScript访问，提供一定的安全性，但仍然可以通过跨站脚本攻击（XSS）暴露。
   - **LocalStorage**和**SessionStorage**：不自动发送给服务器，但容易受到同源策略内的攻击，比如XSS攻击。
5. **用途**：
   - **Cookie**：传统上用于会话管理、保持登录状态，但现在更多用于服务器端的追踪和识别。
   - **LocalStorage**：适合存储用户设置、游戏进度等长期需要保留的数据。
   - **SessionStorage**：适用于存储页面间状态，如表单数据，只在当前窗口或标签页内有效。

# 十、对事件循环的理解？

事件循环（Event Loop）是JavaScript引擎处理异步操作的核心机制，它确保了单线程的JavaScript能够高效地执行同步和异步代码，同时维持执行环境的响应性。事件循环主要基于两个概念：宏任务（Macro Tasks）和微任务（Micro Tasks）。

1. **宏任务（Macro Task）**：主要包括整体的script代码块执行、`setTimeout`、`setInterval`、I/O操作、UI渲染等。每当执行栈为空且存在宏任务时，事件循环就会从宏任务队列中取出一个任务来执行。
2. **微任务（Micro Task）**：主要包括Promise的回调（`.then`、`.catch`）、`process.nextTick`（Node.js环境）、`MutationObserver`的回调等。微任务是在当前宏任务执行结束后，立即执行的任务队列。在完成当前宏任务的所有代码执行后，事件循环会检查微任务队列，并清空所有微任务，然后再开始下一个宏任务。

**事件循环的基本流程**：

1. **执行全局脚本代码**：首先，JavaScript引擎会执行全局脚本的同步代码，此时处于第一个宏任务中。
2. **执行微任务**：当同步代码执行完毕，事件循环会检查是否存在待执行的微任务。如果有，则执行所有微任务，直到微任务队列为空。
3. **执行宏任务**：一旦当前宏任务下的所有微任务执行完毕，事件循环会从宏任务队列中取出下一个任务并执行。执行过程中，如果遇到新的微任务，这些微任务会被添加到微任务队列中，但不会立即执行，而是在当前宏任务完全执行完毕后再执行。
4. **重复上述过程**：事件循环会持续这个过程，不断地检查宏任务队列和微任务队列，直至宏任务队列为空，且微任务队列也为空，此时事件循环才会停止。

例子：

```javascript
   console.log('start');
   setTimeout(() => {
     console.log('setTimeout');
   }, 0);
   new Promise((resolve) => {
     console.log('promise');
     resolve();
   }).then(() => {
     console.log('promise then');
   });
   console.log('end');
```

输出顺序将是：`start` -> `promise` -> `end` -> `promise then` -> `setTimeout`。这是因为Promise的then回调是微任务，会优先于宏任务的setTimeout执行。