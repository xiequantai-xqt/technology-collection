# 一、GET和POST的请求的区别？

1. **请求目的**：
   - **GET**：通常用于获取资源，它是幂等的，意味着多次执行同一GET请求，服务器返回的结果应该是一样的，不会改变服务器状态。
   - **POST**：常用于提交数据，创建新资源或更新现有资源，它可能会改变服务器的状态。
2. **数据传输**：
   - **GET**：数据作为URL的一部分，附加在URL查询字符串中，对大小有限制（通常在2KB到8KB之间，具体取决于浏览器）。
   - **POST**：数据位于请求体（Request Body）中，没有大小限制，可以传输大量数据。
3. **安全性**：
   - **GET**：因为数据在URL中可见，GET请求不适合传输敏感信息，浏览器的历史记录、书签和缓存可能会保存这些信息。
   - **POST**：数据在请求体中，相对更安全，但仍然需要注意数据加密和安全措施。
4. **缓存**：
   - **GET**：可以被浏览器缓存，适合不改变服务器状态的请求。
   - **POST**：通常不被缓存，因为它们可能改变服务器状态。
5. **回退和刷新**：
   - **GET**：按下浏览器的回退按钮，GET请求可以安全地重复，不会再次提交。
   - **POST**：按下回退，POST请求可能会重新提交，导致数据再次发送到服务器，可能会有副作用。
6. **可见性**：
   - **GET**：请求信息对用户和网络监控工具完全可见。
   - **POST**：请求体中的数据对用户可见，但不直接暴露在URL中。
7. **可 bookmarking**：
   - **GET**：可以被收藏为书签，因为它们是幂等的，重复请求不会产生副作用。
   - **POST**：不推荐收藏，因为可能会无意中触发数据提交。
8. **标准**：
   - **GET**：根据HTTP标准，GET应只用于获取信息，而不应有任何副作用。
   - **POST**：POST用于向服务器发送数据，可以创建新资源或修改已有资源。

# 二、POST和PUT请求的区别？

1. **目的和用途**：
   - **POST**：主要用于创建新的资源。当你向服务器发送数据，目的是在服务器上生成一个全新的资源时，应当使用POST请求。例如，向博客平台提交一篇新的文章。
   - **PUT**：主要用于更新已有资源。如果你知道资源的URI（统一资源标识符）并且想要替换或更新该资源的全部信息，应使用PUT请求。比如，修改一篇文章的全部内容。
2. **幂等性**：
   - **POST**：不是幂等的。多次发送相同的POST请求可能会导致创建多个相同的资源副本。每次请求都视为独立的操作，结果可能是不同的。
   - **PUT**：是幂等的。这意味着无论发送多少次相同的PUT请求，服务器上的资源状态将保持一致。多次请求的效果与一次请求相同，不会产生额外的副作用。
3. **请求数据位置**：
   - **POST**：数据通常放在请求体中，也可以通过URL参数传递，但更常见的是在请求体。
   - **PUT**：数据同样放在请求体中，用于替换现有资源的全部内容。
4. **缓存**：
   - **POST**：响应通常不会被缓存，因为它可能产生不同的结果。
   - **PUT**：理论上可以被缓存，因为它是幂等的，但实际应用中是否缓存取决于具体实现和服务器配置。
5. **实际应用中的灵活性**：
   - **POST**：更灵活，既可以用于创建也可以用于某些非幂等的更新操作，具体取决于API设计。
   - **PUT**：更严格，主要针对资源的完整替换或更新，强调资源的唯一性和完整性。
6. **示例场景**：
   - **POST** 示例：在社交媒体应用中发布一条新状态。
   - **PUT** 示例：修改个人资料中的所有信息，如姓名、邮箱等，一次性提交更新。

总结来说，POST和PUT的主要区别在于它们的语义、幂等性和对资源操作的性质，理解这些差异对于设计和使用RESTful API至关重要。

# 三、HTTP状态码304是多好还是少好？

304状态码的出现是好的，因为它意味着以下几点：

1. **效率**：当客户端有有效的缓存时，304状态码减少了不必要的数据传输，节省了网络带宽和服务器资源，提高了响应速度。
2. **用户体验**：对于用户而言，页面加载更快，因为不需要下载完整的资源，尤其是对于大文件或图像等静态内容。
3. **服务器负载**：减少了服务器处理请求的工作量，降低了服务器的负载，特别是在高流量的网站上。

然而，过多的304状态码可能表明：

- **缓存策略**：如果一个网站的大部分请求都返回304，可能表示服务器的缓存策略过于保守，可能需要调整以确保内容的更新能及时到达客户端。
- **内容更新**：如果内容频繁更新但客户端总是收到304，那么用户可能无法看到最新的内容，这对动态网站来说可能是个问题。

所以，理想的情况是，304状态码应该恰当地出现，既充分利用缓存提高性能，又确保内容的更新能及时推送到客户端。服务器和客户端之间的缓存策略需要平衡这两方面的需求。

# 四、常见的HTTP请求方法？

1. **GET**：最常用的方法，用于获取资源。客户端使用GET请求来从服务器获取特定的资源，例如网页、图片或数据。
2. **POST**：用于向服务器发送数据，通常用于创建新的资源。例如，提交表单数据创建一个新的用户账户。
3. **PUT**：与POST类似，但它用于更新已存在的资源。客户端指定资源的URI并提供完整的新资源内容来替换旧的。
4. **DELETE**：删除指定URI所代表的资源。比如，删除一个用户或文件。
5. **HEAD**：类似于GET，但仅返回响应头，不包含资源的主体部分，常用于检查资源的元信息（如日期、大小）而无需下载整个资源。
6. **OPTIONS**：询问服务器支持哪些HTTP方法，用于发现服务器的能力和限制，也常用于预检请求（CORS）。
7. **PATCH**：用于部分更新资源，只发送需要修改的部分，而不是整个资源的内容。
8. **CONNECT**：建立一个到服务器指定端口的TCP连接，常用于HTTPS代理隧道。
9. **TRACE**：回显服务器收到的请求，主要用于调试，检查请求在经过中间服务器时是否被修改。

# 五、HTTP和HTTPS协议的区别？

**HTTP**是互联网上应用最广泛的一种网络协议，用于从Web服务器传输超文本到客户端。它的主要特点是：

1. **非加密**：HTTP协议传输的数据是明文的，不进行任何加密，这可能导致数据在传输过程中被窃听或篡改。
2. **无状态**：HTTP协议自身不记录会话状态，每次请求都是独立的，服务器不知道请求的上下文信息。
3. **默认端口**：HTTP通常使用80端口进行通信。

**HTTPS**是HTTP的安全版本，它结合了HTTP和SSL/TLS协议。主要区别包括：

1. **加密**：HTTPS使用SSL/TLS协议对数据进行加密，确保在客户端和服务器之间的通信是安全的，防止中间人攻击。
2. **身份验证**：通过数字证书，HTTPS可以验证服务器的身份，防止假冒网站欺骗用户。
3. **完整性保护**：HTTPS可以检测数据是否在传输过程中被篡改，保证数据的完整性。
4. **默认端口**：HTTPS通常使用443端口进行通信。

总结来说，HTTPS相比HTTP增加了安全性和隐私保护，是当今互联网上用于访问敏感信息和进行在线交易的首选协议。

# 六、GET方法URL长度限制的原因是什么？

1. **浏览器和服务器的限制**：大多数浏览器和服务器对URL的总长度有限制，主要是出于历史遗留、兼容性和性能考虑。URL过长可能导致解析问题或性能下降，特别是在早期的系统和软件中，对URL长度的处理能力有限。
2. **RFC标准建议**：虽然HTTP协议本身并没有严格规定GET请求的URL长度，但RFC 2616（现在已经被RFC 7230及后续文档替代）建议URL的总长度（包括查询字符串）应限制在2048个字符以内，以确保普遍的可接受性。这些建议虽然不是强制性的，但很多实现遵循了这一指导原则。
3. **缓存和代理服务器**：较短的URL更有利于缓存和代理服务器处理。长URL可能超过这些系统的设计限制，导致缓存失效、处理效率降低或被截断等问题。
4. **安全性考量**：URL可能会出现在日志文件、浏览器历史记录或通过引用链接共享。过长的URL不仅不便于管理，还可能泄露过多的信息，增加安全风险，比如CSRF（跨站请求伪造）攻击的风险。
5. **用户体验**：过长的URL不便于用户记忆和输入，也可能在电子邮件或社交媒体分享时出现问题，影响用户体验。

因此，尽管现代浏览器和服务器对URL长度的处理能力有了很大提升，但遵循URL长度的最佳实践仍然是必要的，以确保应用的兼容性、性能和安全性。在需要传输大量数据时，通常建议使用POST、PUT等方法，将数据放在请求体中而非URL。

# 七、当在浏览器中输入 Google.com 并且按下回车之后发生了什么？

1. **域名解析（DNS解析）**：
   - 浏览器首先查看本地缓存，看是否已经存储了 "Google.com" 的IP地址。
   - 如果本地缓存中没有，浏览器会查询操作系统（通常是通过DNS解析器）来查找对应的IP地址。这可能涉及到本地DNS缓存、路由器的DNS缓存，以及互联网上的DNS服务器。
2. **TCP连接建立**：
   - 一旦获得IP地址，浏览器开始通过TCP协议与服务器建立连接，执行TCP的三次握手过程。
3. **HTTP/HTTPS请求**：
   - 如果访问的是HTTPS网站，浏览器会先进行TLS/SSL握手以建立安全连接。
   - 浏览器构造一个HTTP或HTTPS请求报文，其中包括请求行（比如 "GET / HTTP/1.1"），头部信息（如User-Agent、Accept等）以及可能的请求体（对于GET请求，通常为空）。
4. **请求发送**：
   - 浏览器通过已建立的TCP连接发送请求。
5. **服务器响应**：
   - 服务器接收到请求后，处理请求，可能涉及数据库查询、动态生成内容等。
   - 服务器构建响应报文，包括状态码（如200 OK）、头部信息和响应体（HTML、CSS、JavaScript等资源）。
6. **数据传输**：
   - 服务器通过TCP连接将响应报文发送回浏览器。
7. **页面解析和渲染**：
   - 浏览器接收到响应后，解析HTML文档，构建DOM树。
   - 发现外部资源（如CSS、JavaScript文件），浏览器会发起额外的请求来获取这些资源。
   - CSS文件加载后，浏览器根据CSS构建CSSOM树，然后结合DOM树形成渲染树（Render Tree）。
   - JavaScript执行，可能修改DOM结构，影响渲染。
   - 渲染树被用来绘制页面，呈现给用户。
8. **连接关闭**：
   - 所有资源加载完成后，浏览器和服务器通过TCP四次挥手过程断开连接，释放资源。

# 八、对keep-alive的理解？

1. **目的**：TCP Keep-alive的主要目的是检测连接的另一端是否仍然在线，尤其是在长连接场景下，比如数据库连接、SSH会话或是某些即时通讯应用，这些场景下连接可能长时间没有数据传输。
2. **工作原理**：当启用了TCP Keep-alive选项后，TCP协议栈会周期性地发送探测报文（通常是没有任何数据的ACK包），如果对端仍然在线并能够响应，就会回送一个ACK确认报文。如果连续几次探测（通常是多次，默认次数可配置）都没有收到响应，TCP就会认为连接已经断开，并通知应用层连接已经丢失。
3. **配置与管理**：TCP Keep-alive的参数（如探测间隔、重试次数等）通常是可以配置的，这些配置可以在操作系统级别进行，如在Linux中可以通过`/proc/sys/net/ipv4/tcp_keepalive_time`、`tcp_keepalive_intvl`和`tcp_keepalive_probes`等文件进行设置。
4. **与HTTP Keep-Alive的区别**：虽然名字相似，但HTTP Keep-Alive是另一个概念，它是指在HTTP协议中复用TCP连接，允许同一个TCP连接发送多个HTTP请求和响应，以减少建立和断开连接的开销。这是HTTP层面的优化，而TCP Keep-alive是更底层的TCP协议机制，用于检测连接是否存活。
5. **应用场景**：TCP Keep-alive特别适用于那些需要长期保持连接但数据交换并不频繁的应用场景，比如后台服务间的持续通信、远程监控系统等，以确保连接的有效性和可靠性。

# 九、HTTP协议的优点和缺点？

**优点：**

1. **简单易用**：HTTP协议基于文本，易于理解和实现，使得开发Web应用变得相对简单。
2. **跨平台**：HTTP是平台无关的，可以在各种操作系统和硬件上运行。
3. **无状态**：每个请求都是独立的，这简化了服务器的设计，但也带来了缺点，稍后会提及。
4. **广泛支持**：几乎所有的Web浏览器和服务器都支持HTTP，具有广泛的兼容性和普及性。
5. **扩展性强**：HTTP允许通过添加新的请求方法、状态码和头部来扩展其功能。
6. **缓存机制**：HTTP支持客户端缓存，可以提高响应速度，减轻服务器负载。
7. **通用性**：HTTP不仅用于Web，也被许多其他应用作为数据交换的标准。

**缺点：**

1. **无加密**：HTTP通信是明文的，不提供加密，容易被监听和篡改，存在安全隐患。
2. **无认证**：默认情况下，HTTP不验证服务器或客户端的身份，容易受到中间人攻击。
3. **无完整性校验**：没有内置机制来检查数据在传输过程中是否被篡改。
4. **无状态**：虽然简化了服务器设计，但导致了需要额外的机制（如Cookie或Session）来跟踪用户会话。
5. **效率问题**：每个请求和响应都会包含重复的头部信息，增加网络流量，尤其是在频繁交互的Web应用中。
6. **非持久连接**：在HTTP/1.x中，每个请求都需要建立新的TCP连接，增加了延迟和服务器资源消耗。
7. **性能限制**：在高并发场景下，HTTP/1.x的连接管理可能导致服务器性能瓶颈。

# 十、URL有哪些组成部分？

1. **协议（Scheme）**：定义了访问资源所使用的通信协议。最常见的协议是HTTP和HTTPS，分别代表未加密的超文本传输协议和加密的超文本传输协议安全。
2. **域名（Host or Domain Name）**：标识了资源所在的服务器的网络地址。例如，`www.example.com`。域名通过DNS系统解析成IP地址。
3. **端口（Port，可选）**：指定服务器上的特定服务端口。如果不明确给出，HTTP默认端口为80，HTTPS默认端口为443。如果使用非默认端口，端口号会跟在域名后面，用冒号分隔，如`www.example.com:8080`。
4. **路径（Path）**：描述了资源在服务器上的具体位置或路径。例如，`/index.html`指向服务器根目录下的`index.html`文件。
5. **查询字符串（Query String，可选）**：位于路径之后，由问号`?`引导，用于携带额外的参数或信息给服务器。格式为键值对，多个键值对之间用`&`分隔，如`?key1=value1&key2=value2`。
6. **片段标识符（Fragment Identifier，可选）**：又称锚点，以井号`#`开头，用于指示URL内的某个特定部分，帮助浏览器直接定位到页面内的某一区域。例如，`#section1`。

# 十一、HTTPS通信（握手）过程？

HTTPS握手是一个确保客户端与服务器之间安全通信的过程，它基于SSL/TLS协议。HTTPS握手大致分为以下几个阶段：

1. **客户端发起请求**：
   - 客户端通过发送一个`Client Hello`消息开始握手过程。这个消息中包含了客户端支持的SSL/TLS协议版本、加密套件列表、压缩算法列表以及一个随机生成的数（Client Random）。
2. **服务器响应**：
   - 服务器收到`Client Hello`后，选择双方都支持的最高版本的SSL/TLS协议、加密套件，并在`Server Hello`消息中回复给客户端。同时，服务器还会发送自己的随机数（Server Random）以及服务器的数字证书。证书中包含了服务器的公钥和由证书颁发机构签名的服务器身份信息。
3. **客户端验证证书**：
   - 客户端收到服务器证书后，会验证证书的有效性，包括检查证书是否过期、是否由受信任的CA签发、以及证书的域名是否与正在访问的域名匹配等。如果验证失败，握手过程将终止。
4. **生成预主密钥**：
   - 客户端使用服务器提供的公钥，加密一个预先计算的密钥材料（Pre-Master Secret），并通过`Client Key Exchange`消息发送给服务器。这一步确保了只有拥有对应私钥的服务器才能解密得到这个密钥材料。
5. **计算会话密钥**：
   - 客户端和服务器各自使用之前交换的随机数（Client Random和Server Random）以及预主密钥，通过相同的算法计算出会话密钥（Session Key）。这个会话密钥将在接下来的通信中用于加密和解密数据。
6. **握手完成与密钥交换确认**：
   - 客户端发送`Change Cipher Spec`和`Finished`消息，表示后续的消息都将使用新协商的密钥和算法进行加密。`Finished`消息还包含了一个校验码，用于验证握手过程中没有被篡改。
   - 服务器同样发送`Change Cipher Spec`和`Finished`消息，确认密钥交换完成，并开始使用加密通信。

至此，HTTPS握手过程完成，客户端与服务器之间建立了安全的通信通道，可以开始传输加密的数据。

这个过程确保了数据的机密性、完整性和服务器的身份验证，是HTTPS安全通信的基础。

# 十二、HTTPS的特点？

1. **加密通信**：HTTPS使用SSL/TLS协议对客户端和服务器之间的通信进行加密，确保数据在传输过程中不被窃取或篡改。这包括了对HTTP请求和响应的加密，提供机密性。
2. **身份验证**：HTTPS要求服务器提供由受信任的证书颁发机构(CA)签发的数字证书。这个证书包含了服务器的公钥和身份信息，客户端可以验证服务器的身份，防止中间人攻击和冒名顶替。
3. **完整性保护**：通过哈希函数和MAC（消息验证码）确保数据在传输过程中未被修改，提供数据完整性。
4. **安全套接层**：HTTPS是在HTTP之上建立的，通过SSL/TLS层提供安全服务，这个安全套接层负责加密和解密数据，以及处理证书验证。
5. **安全标志**：在浏览器地址栏，HTTPS连接通常显示一个锁形图标，表明连接是安全的，增强了用户的信任感。
6. **性能影响**：虽然提供了安全，但HTTPS相比于纯HTTP会增加一定的计算和网络延迟，因为需要进行加密和解密过程。不过，现代的硬件和优化的SSL/TLS实现已经大大减少了这种影响。
7. **资源消耗**：服务器需要处理更多的计算资源来处理加密和解密，以及维护证书的有效性。
8. **默认端口**：HTTPS使用443端口，而HTTP使用80端口。
9. **普遍应用**：随着网络安全意识的增强，HTTPS已成为网站和在线服务的标准，特别是涉及到用户登录、支付和个人信息交换的场景。

# 十三、HTTP状态码？

1. **200 OK**：请求成功，是最常见的成功状态码。
2. **404 Not Found**：请求的资源未找到，是最著名的错误状态码之一。
3. **500 Internal Server Error**：服务器遇到了意料不到的情况，无法完成对请求的处理。
4. **403 Forbidden**：服务器理解请求客户端的请求，但是拒绝执行此请求。
5. **301 Moved Permanently**：请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。
6. **302 Found**：请求的资源现在临时从不同的URI响应请求。
7. **401 Unauthorized**：请求要求用户的身份认证。
8. **201 Created**：请求成功并且服务器创建了新的资源。
9. **206 Partial Content**：服务器完成了部分GET请求，响应报文中包含Content-Range指定范围的实体内容。
10. **503 Service Unavailable**：服务器目前无法使用（由于超载或停机维护）。

# 十四、同样是重定向，**307**，**303**，**302**的区别？

1. **302 Found**：这是一个传统的重定向状态码，表示请求的资源已经临时移到了另一个URL。根据HTTP/1.1规范，302默认要求客户端使用相同的方法（如POST）去请求新的URL，但有些浏览器可能会自动将POST转换为GET，这可能导致数据丢失或不正确的处理。
2. **303 See Other**：与302类似，也是用于重定向，但明确要求客户端使用GET方法重新发起请求，无论原始请求是什么方法。这通常发生在POST请求后，服务器希望客户端通过GET获取结果时。
3. **307 Temporary Redirect**：与302类似，但根据HTTP/1.1规范，307要求客户端保持原始请求方法（POST、PUT等），而不是自动转换为GET。这意味着如果原始请求是POST，那么在重定向时也应保持POST。这提供了一种方式来确保敏感数据不会通过GET暴露在URL中。

简而言之，302和307之间的主要区别在于是否允许客户端改变请求方法，而303则是明确要求使用GET进行重定向。这些状态码的使用取决于服务器希望如何处理重定向，以及对客户端行为的控制。

# 十五、DNS 协议是什么？作用是什么？

DNS是一种互联网基础协议，它提供了一种将人类可读的域名转换为计算机可识别的IP地址的方法，同时也支持从IP地址反向解析到域名的功能。DNS协议设计为分布式的、层次化的系统，确保了高效和可靠的域名解析服务。

DNS的作用：

1. **域名解析**：最主要的功能是将用户输入的域名（如 `www.example.com`）转换成对应的IP地址（如 `192.0.2.1`），使得用户的设备能够定位并连接到正确的互联网服务器。这一过程对于用户而言是透明的，极大地提升了网络资源的访问便捷性。
2. **负载均衡和故障转移**：DNS还可以用于实现网站的负载均衡，通过将一个域名解析到多个IP地址，分散访问流量，提高服务可用性和响应速度。同时，当某台服务器不可用时，DNS可以迅速重新指向其他正常工作的服务器，实现故障转移。
3. **层次化结构**：DNS采用树状层次结构，包括根域名服务器、顶级域名服务器（如.com、.org）、权威DNS服务器以及本地DNS缓存服务器等层级，这种结构保证了查询的高效性和容错性。
4. **缓存机制**：为了提高效率，DNS查询结果会在各级DNS服务器及客户端本地进行缓存，这样后续相同查询可以快速响应，无需再次向上级服务器发起请求。
5. **安全辅助**：DNS还支持安全扩展（DNSSEC），用于验证域名记录的真实性，防止DNS欺骗等安全威胁，增强互联网通信的安全性。
6. **其他服务发现**：除了基本的Web服务，DNS还支持邮件服务器定位（MX记录）、文本信息记录（TXT记录）等，帮助实现多种网络服务的发现和配置。

综上所述，DNS协议是互联网基础设施的关键组件，它通过将易于记忆的域名与实际的网络地址（IP）相互映射，不仅简化了用户的网络访问方式，还提供了灵活的服务管理和增强的网络安全性。

# 十六、DNS完整的查询过程？

1. **本地缓存检查**：
   - 客户端（例如，用户的电脑或手机）首先检查其本地DNS缓存，这可能存在于操作系统层面（如Windows的 hosts 文件或Linux的 /etc/hosts）或者在浏览器内部。
2. **本地DNS服务器查询**：
   - 如果本地缓存中没有找到所需记录，客户端会将DNS查询发送到配置的本地DNS服务器，通常是Internet Service Provider (ISP) 提供的DNS服务器，也称为存根解析器。
3. **递归查询**：
   - 本地DNS服务器收到请求后，如果其缓存中也没有对应记录，它会开始递归查询过程。首先，它向根域名服务器发起请求。
4. **根域名服务器指引**：
   - 根域名服务器并不存储具体的域名记录，但它们知道所有顶级域（TLD，如.com、.org、.net）的权威DNS服务器的地址。根服务器会返回相应顶级域的权威服务器的IP地址。
5. **顶级域服务器查询**：
   - 本地DNS服务器接着向顶级域服务器发送请求，顶级域服务器则负责其管理的域（如.com域）的DNS记录。
6. **权威域名服务器查询**：
   - 顶级域服务器会提供负责特定二级域名（如.example.com）的权威DNS服务器的地址。本地DNS服务器再向这个权威服务器查询。
7. **记录查找**：
   - 权威域名服务器拥有目标域名的完整DNS记录，包括A记录（IP地址映射）、CNAME记录（别名）等。如果找到所需的记录，它会返回给本地DNS服务器。
8. **结果返回**：
   - 本地DNS服务器收到响应后，将结果缓存起来，然后返回给客户端。客户端得到IP地址后，就可以使用这个IP来连接目标服务器。
9. **缓存记录**：
   - 客户端也会缓存这次查询的结果，以便未来更快地访问同一域名。

整个过程确保了从客户端到目标服务器的高效域名解析，同时通过缓存机制降低了网络延迟和服务器压力。如果DNS服务器之间存在安全认证和加密（如DNSSEC），还会进行额外的签名验证，以保证数据的完整性和安全性。

# 十七、对 WebSocket 的理解？

WebSocket 是一种在客户端和服务器之间建立长期、双向通信信道的协议，它允许双方进行全双工（即同时接收和发送数据）的数据交换。以下是WebSocket的一些关键特性：

1. **持久连接**：
   - WebSocket 创建一次连接后，该连接保持打开状态，直到一方关闭连接。这与HTTP协议中的短连接不同，HTTP每次请求都需要建立新的连接。
2. **握手协议**：
   - WebSocket 连接的建立始于一个HTTP Upgrade请求，客户端发送一个`Upgrade: websocket`头，请求升级到WebSocket协议。服务器回应一个101（Switching Protocols）状态码，确认升级成功。
3. **低开销**：
   - WebSocket 数据帧格式比HTTP更简洁，减少了头部信息，降低了通信的延迟和带宽消耗。
4. **双向通信**：
   - 一旦连接建立，服务器和客户端都可以随时发送数据，而不需要等待对方的响应，这使得实时应用（如聊天、游戏、股票交易等）的实现更为简单。
5. **端口号**：
   - 默认情况下，WebSocket 连接使用80端口（HTTP）或443端口（HTTPS），这使得它可以通过大多数防火墙和代理服务器，因为这些端口通常对HTTP开放。
6. **事件驱动**：
   - 在JavaScript中，WebSocket对象提供了`open`、`message`、`error`和`close`等事件，便于应用程序监听连接的状态变化和数据收发。
7. **应用范围**：
   - WebSocket 适用于需要实时交互的场景，如在线协作工具、实时推送通知、实时地图更新、在线游戏等，它极大地提高了数据传输的效率和用户体验。
8. **安全性**：
   - WebSocket 可以与TLS/SSL（即wss://）结合使用，提供加密和身份验证，确保数据传输的安全性。

WebSocket 的出现解决了HTTP协议在长轮询、 comet 等技术上的不足，为现代互联网应用提供了高效、实时的数据通信机制。

# 十八、即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？

即时通讯（IM）的实现方式包括短轮询、长轮询、Server-Sent Events（SSE）和WebSocket，它们之间的主要区别在于数据传输的方式、效率和实时性：

1. **短轮询（Short Polling）**：
   - 客户端定期（比如每隔几秒）发送HTTP请求到服务器，询问是否有新数据。
   - 缺点：频繁的请求导致大量无效的往返，浪费带宽和服务器资源，而且实时性较差，因为新数据可能会在两次请求之间产生。
2. **长轮询（Long Polling）**：
   - 客户端发送请求后，服务器不立即响应，而是保持连接打开，直到有新数据或超时才返回响应。
   - 优点：相比短轮询，减少了不必要的请求，提高了实时性。
   - 缺点：仍然基于HTTP，服务器需要维护大量的打开连接，可能导致资源耗尽。
3. **Server-Sent Events（SSE）**：
   - 使用HTTP流技术，服务器可以持续向客户端推送数据，而客户端只需保持一个打开的HTTP连接。
   - 优点：单向数据流，服务器可以主动推送，比轮询更高效，且只占用一个连接。
   - 缺点：不支持双向通信，仅限于服务器向客户端推送。
4. **WebSocket**：
   - 建立一个持久的TCP连接，允许双向通信，即客户端和服务器可以同时发送和接收数据。
   - 优点：实时性最好，效率高，适合双向实时通信的应用场景，如聊天、游戏等。
   - 缺点：需要处理连接的建立和维护，可能需要更多的服务器资源，且不被所有浏览器和防火墙支持。

总结来说，短轮询和长轮询基于HTTP，适合简单的实时需求，但效率较低；SSE改进了实时性，但仍为单向通信；WebSocket提供最高效的双向实时通信，但需要更多的服务器管理和资源。选择哪种技术取决于具体应用场景的需求和资源限制。