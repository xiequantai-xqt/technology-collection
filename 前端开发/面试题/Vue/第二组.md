# 一、`$route 和$router` 的区别？

**$route**:

- **用途**：$route 是一个反应式对象，用于获取当前路由的状态信息。它包含了当前URL解析得到的信息，如路径（path）、查询参数（query）、参数（params）、哈希（hash）等。
- **功能**：主要用于读取路由信息，如在组件内部根据路由参数来决定渲染逻辑，或者监控路由变化（通过watch监听$route的变化）。
- **访问方式**：在Vue组件内部直接可用，无需额外导入。

**$router**:

- **用途**：$router 是Vue Router的实例，提供了操作路由的功能。它包含了所有路由的配置信息以及进行导航的方法。
- **功能**：包括但不限于导航到不同的URL（如`$router.push()`、`$router.replace()`）、获取当前路由器的实例配置、添加路由守卫（如全局前置守卫`beforeEach`）、以及管理路由历史（如`$router.go()`）。
- **访问方式**：通常在Vue实例中通过注入的方式使用，或者在路由配置文件中直接操作。

**总结**：

- **本质区别**：$route关注于当前路由的状态信息，是只读的；而$router关注于路由的操控和管理，可以用来实现页面间的导航和路由状态的改变。
- **使用场景**：当你需要根据当前路由信息展示不同内容时，使用$route；当你需要控制页面跳转或添加路由守卫等功能时，使用$router。

# 二、Vuex 的原理？

1. **状态集中管理**：Vuex通过一个单一的store（仓库）保存应用的所有状态。这个store就是一个JavaScript对象，包含应用的state（状态）、mutations（变更函数）、actions（动作）、getters（计算属性）和modules（模块）。
2. **响应式数据**：Vuex中的state是响应式的，当state发生改变时，所有依赖于此state的组件都会自动更新。这得益于Vue的响应式系统，确保了视图与状态的一致性。
3. **严格的状态变更**：为了保证状态变更的可追踪和可预测，Vuex强制所有的状态变更都必须通过mutations来完成。Mutations是同步的，且每个mutation都有一个字符串类型的事件类型（type）和一个回调函数（handler），这个函数接收state作为第一个参数，第二个参数可选，通常用于传递导致状态变更的载荷（payload）。
4. **异步操作与Actions**：由于mutations必须是同步的，对于需要处理异步操作（如API调用）的情况，Vuex引入了actions。Actions可以包含任意异步操作，并通过commit调用来触发mutations，从而间接更新state。
5. **模块化**：对于复杂的应用，Vuex支持模块划分，每个模块拥有自己的state、mutations、actions和getters，这有助于组织和管理大型应用的状态。
6. **Getters**：类似于Vue的computed属性，getters用于从store的状态派生出一些状态，可以认为是store的计算属性。Getters可以接受其他getters作为参数，也可以接受state作为参数，使得状态的获取更加灵活和高效。

# 三、Vuex中action和mutation的区别？

**Mutation**:

1. **目的**：Mutation是Vuex中更改状态（state）的唯一途径，它直接处理state的修改，确保这些变更可追踪且容易调试。
2. **性质**：Mutation必须是同步函数，这意味着它们在执行期间不会进行异步操作，如API调用或setTimeout，这有助于保持状态变更的简洁性和可预测性。
3. **调用方式**：Mutation通过`store.commit`方法触发，传入一个mutation的名称（字符串）和可选的载荷（payload）。
4. **记录和调试**：Vuex DevTools可以记录每次mutation的执行，帮助开发者追踪状态变化的历史，便于调试和理解应用的行为。

**Action**:

1. **目的**：Action负责处理复杂的逻辑，特别是那些涉及异步操作的逻辑，比如调用后端API。它们不直接修改state，而是通过触发mutation来间接更新state。
2. **性质**：Action可以是异步函数，这使得它们非常适合处理网络请求、长时间运行的任务等场景。
3. **调用方式**：Action通过`store.dispatch`方法触发，同样接收一个action的名称和可选的载荷。
4. **流程控制**：Action内部可以包含多个步骤，包括调用API、处理返回数据、最后通过`commit`调用一个或多个mutation来更新state。
5. **分发与链式调用**：Action之间可以相互调用（分发），形成复杂的异步操作流程，而且支持Promise的链式调用，便于编写和维护异步逻辑。

**总结**： Mutation关注于同步地改变应用状态，强调的是状态管理的纯函数特性，确保状态变更的可跟踪性。而Action则提供了处理异步操作的能力，让Vuex能够应对更复杂的业务逻辑，同时保持整体状态管理的清晰和可控。两者相辅相成，共同构成了Vuex状态管理的核心机制。

# 四、Vuex 和 localStorage 的区别？

**Vuex**：

1. **作用**：Vuex是Vue.js应用的状态管理库，它集中管理组件之间共享的状态，使得状态的更新和访问变得有序和可追踪。
2. **数据存储**：Vuex的状态存储在内存中，随着Vue应用的运行而存在，关闭或刷新浏览器会丢失。
3. **响应式**：Vuex的状态是响应式的，当状态改变时，依赖于该状态的组件会自动更新。
4. **变更控制**：状态变更必须通过提交`mutation`来完成，保证了状态变更的可预测性和可调试性。
5. **生命周期**：Vuex有其自身的生命周期，包括初始化、更新、模块拆分等，方便管理和组织状态。
6. **辅助工具**：Vuex提供了如getter、action、mutation、module等辅助工具，帮助管理复杂的应用状态。

**localStorage**：

1. **作用**：localStorage是HTML5提供的本地存储API，用于在用户的浏览器上持久化存储数据，即使关闭浏览器或重启电脑，数据依然存在。
2. **数据类型**：localStorage只能存储字符串，如果需要存储复杂数据类型（如对象或数组），通常需要使用JSON.stringify和JSON.parse进行序列化和反序列化。
3. **存储容量**：localStorage的存储空间通常为5MB左右，比内存中的Vuex存储空间大。
4. **无状态管理**：localStorage没有响应式更新，当数据变化时，需要手动处理页面的更新。
5. **跨域限制**：localStorage遵循同源策略，不同源的页面无法共享数据。

**应用场景**：

- Vuex适合于管理应用运行时的状态，尤其适用于需要实时响应状态变化的场景，以及组件间的复杂交互。
- localStorage更适合于存储用户设置、应用配置等需要长期保留的数据，或者在不同会话之间需要共享数据但不需要实时响应的情况。

**总结**： Vuex和localStorage各有侧重，Vuex是为了解决Vue应用内部的状态管理问题，提供响应式和控制流，而localStorage是浏览器提供的持久化存储解决方案，两者在应用场景和数据管理上有明显的区别。在实际项目中，开发者通常会结合使用，以实现最佳的用户体验和数据管理。

# 五、Redux 和 Vuex 有什么区别，它们的共同思想？

**Redux**：

1. **平台无关性**：Redux 是一个独立的状态管理库，可以与任何UI框架（不仅仅是React）一起使用。
2. **不可变数据**：Redux 强制使用不可变数据，每次状态更新都会返回一个新的状态对象，而不是直接修改旧状态。
3. **单一数据源**：Redux 应用只有一个单一的store（状态树），所有状态都集中在这里管理。
4. **action与reducer**：Redux 中，状态更新通过action触发，这些action被reducer函数处理，reducer是纯函数，接受旧状态和action，返回新状态。
5. **中间件支持**：Redux 提供强大的中间件系统，允许在action到达reducer前进行拦截和处理，支持异步操作和日志记录等。
6. **开发工具**：Redux DevTools 提供了丰富的调试功能，可以记录每一个状态变化，帮助开发者理解状态流转。

**Vuex**：

1. **Vue专用**：Vuex 是专门为Vue.js框架设计的状态管理库。
2. **可变数据**：与Redux不同，Vuex中的状态是可以直接修改的，尽管推荐通过mutation来进行。
3. **模块化**：Vuex 自带模块化功能，方便大型应用的状态分割管理。
4. **mutation与action**：Vuex 使用mutation来处理同步状态变更，action则用于处理异步逻辑，但不强制要求所有异步操作都通过action。
5. **状态、getter、mutation、action**：Vuex 定义了明确的角色分工，使状态管理结构清晰。
6. **便捷访问**：Vuex 提供了mapGetters和mapActions等辅助函数，方便组件访问和触发状态变更。

**共同思想**：

- **单一数据源**：无论是Redux还是Vuex，都提倡应用有一个单一的、集中的状态树，作为整个应用状态的唯一来源。
- **状态变更规则**：二者都强调状态变更应该是可预测的，通过明确的规则（Redux中的reducer，Vuex中的mutation）来执行。
- **分离关注点**：通过将状态管理从组件中抽离出来，使得状态逻辑和视图逻辑分离，提高代码的可维护性和可测试性。
- **响应式更新**：都支持状态变更后自动更新相关联的视图，确保用户界面与状态保持同步。

总的来说，Redux和Vuex在设计理念上有很多相似之处，都是为了更好地管理应用状态，提升开发效率和应用的可维护性。它们的主要区别在于适用框架、数据处理方式（不可变vs可变）、以及一些特性和实现细节。

# 六、Vuex有哪几种属性？

有五种，分别是 State、 Getter、Mutation 、Action、 Module

- state => 基本数据(数据源存放地)
- getters => 从基本数据派生出来的数据
- mutations => 提交更改数据的方法，同步
- actions => 像一个装饰器，包裹mutations，使之可以异步。
- modules => 模块化Vuex

# 七、Vuex和单纯的全局对象有什么区别？

1. **响应式状态管理**：Vuex的状态存储是**响应式**的，这意味着当Vue组件从store中读取状态时，如果store中的状态发生变化，所有依赖这些状态的组件会自动更新。相比之下，使用单纯的全局对象来存储状态，不具备这种自动更新视图的能力，你需要手动处理状态变化后的UI更新。
2. **状态变更机制**：Vuex强制通过**Mutation**来改变状态，这是一种同步操作，且所有变更都被集中记录，使得状态变更过程清晰可追踪。而在全局对象中，状态可以在任何地方被随意修改，这不仅难以追踪状态变更的源头，还可能导致难以预料的副作用和bug。
3. **异步操作处理**：Vuex引入了**Action**来处理异步操作，如API调用等，Action可以触发Mutation来间接更新状态，这保持了状态管理的清晰性和可维护性。全局对象本身不提供管理异步逻辑的机制。
4. **开发工具支持**：Vuex与Vue DevTools集成，提供了强大的调试功能，可以记录每一次状态变更的细节，帮助开发者快速定位问题。全局对象的状态变更则难以被此类工具跟踪。
5. **模块化和可扩展性**：Vuex支持**模块化**，允许将庞大的状态树分割成小的、可管理的模块，这对于大型项目至关重要。全局对象没有内建的模块化机制，随着应用复杂度增加，状态管理会变得混乱不堪。
6. **集中管理与解耦**：Vuex通过集中存储和管理应用状态，促进了组件之间的解耦，使得状态逻辑与视图逻辑分离，提高了代码的可读性和可维护性。全局对象直接暴露在各个组件中使用，容易造成组件间的紧耦合。

综上所述，虽然使用全局对象可以简单地在组件间共享数据，但Vuex通过提供响应式、集中化、模块化的状态管理机制，以及对异步操作和调试的强大支持，显著提升了状态管理的效率和质量，更适合于中大型单页应用的开发。

# 八、为什么 Vuex 的 mutation 中不能做异步操作？

Vuex 的 mutation 被设计为同步的原因主要有以下几点：

1. **可预测性**：由于 mutation 必须是同步的，这确保了每次 mutation 的执行都是确定的，没有异步操作带来的不确定性。这样，开发者可以更容易地理解和追踪应用状态的变化，有利于调试和测试。
2. **调试友好**：Vuex 的开发工具（Vue DevTools）能够记录并展示每次 mutation 的执行，如果 mutation 中包含异步操作，那么记录和回放这些状态变更就会变得非常困难，因为异步操作的完成时间是不可预知的。
3. **状态更新的原子性**：Mutation 被视为一个原子操作，它应该一次性完成对状态的修改。如果允许异步操作，那么在状态更新的过程中可能会出现并发问题，导致状态不一致。
4. **控制流程**：Vuex 通过 actions 处理异步操作，这样可以保持 mutation 的简洁性，将复杂的业务逻辑和数据获取过程隔离，使得状态变更的控制流程更清晰。
5. **避免错误**：异步操作可能在错误处理上带来复杂性，尤其是在多个组件可能同时尝试修改状态的情况下。通过限制 mutation 为同步，可以避免这些潜在的冲突。
6. **设计原则**：Vuex 的设计原则之一就是保持状态变更的可预测性和一致性，而异步操作往往违背了这一原则。

综上所述，Vuex 将异步操作放到 actions 中是为了保持状态管理的整洁、可预测和易于调试，同时也提供了更好的控制和组织结构。通过这种方式，Vuex 可以帮助开发者构建更可靠和易于维护的Vue应用。

# 九、Vue3.0有什么更新？

1. **性能提升**：Vue3.0对虚拟DOM（Virtual DOM）的实现进行了重写，称为“Vue3的Proxy-based观测系统”，这使得Vue能够更高效地追踪数据变化，减少了不必要的渲染，从而提高了整体应用性能。此外，Vue3还改进了组件初始化速度，降低了内存占用。
2. **Composition API**：Vue3引入了Composition API，这是一种新的编程模型，它允许开发者以更模块化和复用性更高的方式组织代码。Composition API使用`setup()`函数作为组件入口，替代了传统的Options API，使得逻辑复用和复杂组件的构建更为简便。
3. **改进的Template编译**：Vue3优化了模板编译机制，比如通过将作用域插槽（Scoped Slots）改为函数式方式，使得只有当子组件真正需要更新时才重新渲染，避免了不必要的父组件渲染，提高了渲染性能。
4. **Teleport**：Vue3新增了`<teleport>`组件，允许开发者将组件内容渲染到DOM树中的任意位置，这对于模态框、提示信息等需要脱离当前组件层级的UI元素特别有用。
5. **Tree-shaking**：Vue3支持Tree-shaking，意味着在打包过程中可以移除未使用的代码，减小最终的包体积，提高了应用加载速度。
6. **更好的TypeScript支持**：Vue3从设计之初就考虑到了TypeScript的支持，提供了更完整的类型定义，使得在使用TypeScript开发Vue应用时体验更加流畅。
7. **Fragment与Suspense**：Vue3原生支持组件片段（Fragments），允许一个组件返回多个根节点。同时引入了`<suspense>`组件，用于处理异步组件加载或数据获取时的占位符和错误边界。
8. **改进的Reactivity系统**：Vue3的响应式系统更加灵活，不仅可以观测对象属性的变化，还能观测数组的变化，以及属性的添加和删除，使得状态管理更加精细和高效。
9. **Router和Vuex的更新**：Vue生态系统中的Vue Router和Vuex也针对Vue3进行了更新，提供了更好的性能和更简洁的API。

这些更新体现了Vue3.0在保持原有易用性的同时，对现代前端开发需求的深入洞察和技术创新，旨在帮助开发者构建更强大、更灵活、更高效的Web应用。

# 十、defineProperty和proxy的区别？

1. **静态 vs 动态**：`defineProperty`是静态的，一旦定义，属性的元数据基本固定；而`Proxy`是动态的，可以改变其行为，提供更灵活的拦截和控制。
2. **拦截范围**：`defineProperty`只能单独定义一个属性，而`Proxy`可以拦截对象的所有操作，包括访问、修改、删除属性等。
3. **元数据控制**：`defineProperty`可以精确控制单个属性的元数据，如可写性、可枚举性、可配置性；`Proxy`则提供了更全面的控制，可以定义更复杂的拦截规则。
4. **使用场景**：`defineProperty`适合于对特定属性进行特殊处理或保护，而`Proxy`适用于需要广泛拦截和控制对象操作的场景，如数据验证、缓存等。
5. **兼容性**：`defineProperty`在ES5中就已经可用，浏览器支持较好；`Proxy`是ES6的新特性，部分老版本浏览器可能不支持，需要考虑兼容性问题。
6. **性能**：`Proxy`通常比`defineProperty`开销更大，因为它涉及到更多的运行时操作和拦截。

# 十一、Vue3.0 为什么要用 proxy？

1. **全方位拦截**：`Proxy`可以拦截对象上的所有操作，包括读取（get）、设置（set）、删除（deleteProperty）、枚举（enumerate）、迭代（ownKeys）、赋值（has）、方法调用（apply、construct）等，这比`Object.defineProperty`只能拦截个别属性的get和set操作要强大得多。
2. **动态监听**：在Vue2.x中，`Object.defineProperty`只能在对象创建时定义响应式属性，一旦对象创建，就无法动态添加新的响应式属性。而`Proxy`可以监听对象的动态添加和删除属性，使得Vue3能更好地适应动态数据结构。
3. **深度监听**：在Vue2.x中，为了实现深度响应式，需要递归地对对象的每个层级进行定义，这在处理嵌套数据结构时性能较低。而`Proxy`可以监听整个对象，无需手动递归，提升了性能。
4. **更少的运行时开销**：虽然`Proxy`在创建时可能有更高的开销，但一旦创建，它在后续操作中的性能通常优于`Object.defineProperty`，特别是在处理大量数据时。
5. **更好的类型安全**：与`Object.defineProperty`相比，`Proxy`更易于与TypeScript等强类型语言配合，提供更好的类型检查和智能感知。
6. **更好的开发体验**：`Proxy`使得Vue3的响应式系统更加直观和简洁，开发者可以编写更接近自然语言的代码，提高代码的可读性和可维护性。
7. **兼容未来技术**：`Proxy`是ES6的特性，符合现代JavaScript的发展趋势，使用它能更好地利用现代浏览器的特性，为未来的功能扩展和优化打下基础。

# 十二、对虚拟DOM的理解？

1. **概念阐述**：虚拟DOM是一种轻量级的内存数据结构，它是真实DOM的一种抽象表示。虚拟DOM使用JavaScript对象树来模拟实际网页的DOM结构，每个对象代表一个真实的DOM节点，包含节点的类型、属性和子节点信息。
2. **工作原理**：
   - **初始化阶段**：当应用启动时，虚拟DOM会首先构建一个与初始UI对应的对象树，这个过程通过JavaScript完成。
   - **更新阶段**：当应用状态发生变化时，虚拟DOM会迅速重新计算新的UI结构（新的对象树），然后通过高效的算法（如Diff算法）对比新旧虚拟DOM树的差异。
   - **渲染阶段**：仅将计算出的最小差异应用到实际的DOM上，而非重新渲染整个页面，这样大大减少了DOM操作的次数，提高了页面的更新效率。
3. **优势**：
   - **性能优化**：通过减少实际DOM操作，有效减轻了浏览器渲染负担，提高了页面响应速度。
   - **跨平台能力**：虚拟DOM作为一层抽象，使得前端框架（如React、Vue）可以更容易地实现跨平台渲染，如在Web、移动应用或服务端渲染。
   - **易于调试和测试**：虚拟DOM提供了更友好的调试工具，可以追踪状态变化和DOM更新的过程，便于开发者定位问题。
4. **实现思路**：虽然虚拟DOM的具体实现细节因框架而异，但核心思想都是利用数据驱动视图的理念，通过对比算法找到最高效的DOM更新策略，以此达到高效更新界面的目的。
5. **与真实DOM的关系**：虚拟DOM并不是用来替代真实DOM，而是作为中介层，减少直接操作真实DOM的频率，从而提升应用性能。

总结来说，虚拟DOM是现代前端框架中一项关键技术，它通过在内存中模拟DOM结构，实现了高效、快速的UI更新机制，是提高Web应用性能和开发效率的关键所在。

# 十三、虚拟DOM的解析过程？

1. **创建虚拟节点树（VNode Tree）**：
   - 应用启动时，首先会根据应用程序的初始状态和模板，使用JavaScript对象来创建虚拟DOM树。每个VNode代表一个DOM节点，包含了标签名（tag）、属性（props）、子节点（children）以及其他元数据。
2. **状态变化监听**：
   - 当应用状态发生变化时，比如用户交互或数据流更新，框架会监听到这些变化并触发相应的逻辑。
3. **生成新的VNode Tree**：
   - 根据状态变化，重新计算出一个新的VNode树来反映更新后的UI。这个过程通常通过重新执行组件的渲染函数完成。
4. **差异检测（Diff算法）**：
   - 新旧两个VNode树被比较，以找出最小的差异集。这个算法比较复杂，但通常遵循一定的规则，如键值对匹配、元素类型比较等，以减少不必要的DOM操作。
5. **批处理更新**：
   - 找到的差异被收集起来，然后一次性应用到真实DOM树上，而不是立即更新。这种批量更新策略可以减少浏览器渲染的次数，提高性能。
6. **DOM更新**：
   - 使用收集到的差异列表，只对必要的DOM节点进行操作，如添加、删除或更新节点及其属性。这个过程也被称为“patch”。
7. **渲染**：
   - 最后，浏览器根据更新后的DOM树重新绘制用户界面，用户看到的是最新的视图。

虚拟DOM的设计目标是通过减少对真实DOM的操作来提高性能，同时提供了一种跨平台和易于维护的状态管理机制。通过这种方式，现代前端框架能够实现高效的UI更新，同时保持应用的响应性和性能。

# 十四、DIFF算法的原理？

IFF算法是现代前端框架（如React、Vue）中用于高效更新用户界面的关键技术。其核心目的是通过比较新旧两棵虚拟DOM树（VNode Tree），找出两者之间的最小差异，并仅对这些差异部分进行实际DOM操作，从而减少不必要的重渲染，提升性能。DIFF算法的基本原理可以概括为以下几个步骤：

1. **树遍历**：
   - 首先，算法会遍历新旧两棵虚拟DOM树，从根节点开始，逐层向下比较每个节点。
2. **节点比较**：
   - 对于每个节点，算法会检查节点的类型（是否为同一类型的元素）、属性（是否有新增、删除或修改的属性）以及文本内容（对于文本节点）。
   - 如果节点类型不同，直接替换整个节点。
   - 如果节点类型相同，则进一步比较属性和子节点。
3. **复用节点**：
   - 为了提高效率，如果发现新旧节点的类型相同，并且满足复用条件（如具有唯一key属性），算法倾向于复用旧节点，仅更新必要的属性或子节点，而不是创建全新的DOM节点。
4. **递归比较子树**：
   - 对于拥有子节点的元素，算法会递归地对子树进行相同的比较过程，直到找到差异或遍历完所有节点。
5. **最小变更策略**：
   - DIFF算法的核心在于找出最小的变更集，即尽可能减少DOM操作。这通常通过优化的算法实现，比如分层比较、最长递增子序列（LIS）算法等，来快速定位变动。
6. **批量更新**：
   - 为了进一步提升性能，差异计算完成后，框架通常会批量执行DOM操作，而不是一个接一个地更新，以减少重排和重绘的次数。